
CSS (Cascading Style Sheets) syntax is used to define the style and layout of HTML elements on a web page. 
The basic structure of CSS involves selectors and declarations that define which HTML elements should be styled and how they should be styled.

Basic CSS Syntax:
selector {
  property: value;
}

Key Components:
1. Selector:
The selector specifies which HTML elements you want to style. It can be a tag name, class, ID, or other HTML attribute.
Examples of selectors:
p (targets all <p> elements)
.class-name (targets elements with a specific class)
#id-name (targets an element with a specific ID)

2. Declaration Block:
The declaration block contains one or more declarations, enclosed in curly braces {}.
Each declaration defines a CSS property and the corresponding value, separated by a colon :.
Multiple declarations are separated by semicolons ;.

3. Properties:
CSS properties are predefined keywords that define aspects of the style, such as color, font-size, margin, etc.

4. Values:
The value assigned to a property defines how that property will affect the element.
Example values include colors (red, #FF5733), sizes (12px, 1.5em), or specific keywords (center, block).
/* Selector targets all <p> elements */
p {
  color: blue; /* Text color set to blue */
  font-size: 16px; /* Font size set to 16px */
  margin: 10px 0; /* 10px margin on top and bottom */
}

/* Selector targets elements with class "header" */
.header {
  background-color: lightgray; /* Light gray background */
  text-align: center; /* Center-align text */
}

/* Selector targets element with id "main" */
#main {
  width: 80%; /* Set width to 80% */
  padding: 20px; /* Add 20px padding inside the element */
}
Detailed Breakdown:
Selector: p – applies the style to all <p> elements.
Property: color, font-size, margin – specifies what aspect of the element's style you want to change.
Value: blue, 16px, 10px 0 – specifies how that property should be set.

CSS Comments:
Comments in CSS are enclosed within /* */ and are ignored by the browser. They are useful for documenting the code.
/* This is a comment */
p {
  color: red; /* This sets the text color to red */
}

Multiple Selectors:
You can apply the same style to multiple elements by separating the selectors with a comma.
h1, h2, h3 {
  color: navy;
  font-family: Arial, sans-serif;
}

Nesting Selectors:
To style specific elements inside other elements, you can "nest" selectors.
/* Target only <a> elements inside <nav> */
nav a {
  color: green;
  text-decoration: none;
}

CSS Syntax Best Practices:
Use consistent indentation and spacing for readability.
Group related declarations to keep your styles organized.
Use comments to explain the purpose of specific styles when necessary.
Conclusion:
CSS syntax consists of selectors that target HTML elements, followed by declaration blocks containing properties and their corresponding values. 
Mastering CSS syntax enables you to control the layout, appearance, and style of web content efficiently.

CSS syntax can extend to more advanced and complex structures, especially when incorporating various selectors, combinators, functions, and pseudo-classes/elements. 
Here's a more extensive syntax overview that covers different types of selectors, declaration techniques, and advanced features:

1. CSS Rules Structure:
selector {
  property1: value1;
  property2: value2;
  property3: value3;
  /* ... additional declarations ... */
}

2. Multiple Selectors:
To apply the same styles to multiple selectors, separate them with a comma.
h1, h2, h3 {
  color: darkblue;
  text-transform: uppercase;
}

3. Grouping and Nesting Selectors:
Descendant Combinator:

Targets elements that are descendants of another element.
div p {
  color: green; /* Targets <p> elements inside <div> */
}

Child Combinator (>):
Targets direct child elements.
nav > ul > li {
  list-style-type: square; /* Targets <li> that are direct children of <ul> */
}

Adjacent Sibling Combinator (+):
Selects an element immediately following a specific element.
h2 + p {
  color: red; /* Targets the <p> element directly after an <h2> */
}

General Sibling Combinator (~):
Selects all elements that are siblings (following elements) of a specific element.
h2 ~ p {
  color: purple; /* Targets all <p> elements following an <h2> */
}

4. Attribute Selectors:

Basic Attribute Selector:
Matches elements with a specific attribute.
input[type="text"] {
  background-color: lightyellow; /* Targets input elements of type 'text' */
}

Attribute with Partial Matching:
Starts with (^=):
a[href^="https"] {
  color: green; /* Targets links starting with 'https' */
}

Contains (*=):
a[href*="example"] {
  color: orange; /* Targets links containing 'example' */
}

Ends with ($=):
a[href$=".pdf"] {
  color: red; /* Targets links ending with '.pdf' */
}

5. Pseudo-Classes and Pseudo-Elements:

Pseudo-Classes (:):
Used to define a special state of an element.

:hover – Applies styles when the user hovers over an element.
button:hover {
  background-color: blue;
  color: white;
}

:nth-child(n) – Targets the nth child of its parent.
li:nth-child(2) {
  color: red; /* Targets the second <li> */
}

:nth-of-type(n) – Targets the nth element of a specific type within its parent.
p:nth-of-type(3) {
  font-weight: bold; /* Targets the third <p> */
}

:not(selector) – Targets all elements except the specified selector.
p:not(.highlight) {
  color: gray; /* Targets all <p> elements that do not have class 'highlight' */
}

Pseudo-Elements (::):
Used to style specific parts of an element.

::before – Inserts content before the element’s content.
h1::before {
  content: "★ ";
  color: gold;
}

::after – Inserts content after the element’s content.
h1::after {
  content: " ★";
  color: gold;
}

::first-letter – Styles the first letter of the text.
p::first-letter {
  font-size: 2em;
  color: red;
}

6. Inheritance and Cascading:
CSS properties can be inherited or overridden by child elements. 
The cascade determines which styles apply if multiple rules target the same element.

Specificity: The more specific a rule is, the higher its priority.
/* ID selectors are more specific */
#header p {
  color: blue; /* This has a higher specificity than a class or tag selector */
}
/* Class selectors */
.header p {
  color: red;
}
/* Tag selectors */
p {
  color: green; /* This will be overridden by the class or ID selector */
}

Important Declaration (!important):
The !important keyword forces a property to override other declarations, regardless of specificity.
p {
  color: yellow !important; /* Forces this style, overriding others */
}

7. CSS Functions:

calc():
Performs calculations to set CSS property values.
div {
  width: calc(100% - 50px); /* Dynamically calculates width */
}

var():
var(--variable-name, fallback-value).
Uses CSS variables (custom properties).
:root {
  --main-color: blue;
}
div {
  color: var(--main-color); /* Uses the custom property */
}

rgba() and hsla():
Allow specifying colors with opacity.
div {
  background-color: rgba(255, 0, 0, 0.5); /* Red with 50% opacity */
}
div {
  background-color: hsla(120, 100%, 50%, 0.3); /* Green with 30% opacity */
}

8. Media Queries (Responsive Design):
CSS allows you to apply styles based on device size or other characteristics.
@media (max-width: 600px) {
  body {
    background-color: lightblue; /* Changes background for screens smaller than 600px */
  }
}

9. CSS Grid and Flexbox Syntax:
Flexbox:
Flexbox is used for 1D layouts, allowing easy alignment of items along a row or column.
.container {
  display: flex;
  justify-content: space-between; /* Aligns items along the main axis */
  align-items: center; /* Aligns items along the cross axis */
}

CSS Grid:
CSS Grid is used for 2D layouts, managing rows and columns simultaneously.
.container {
  display: grid;
  grid-template-columns: 1fr 2fr; /* Creates a two-column layout */
  grid-gap: 10px; /* Adds a gap between grid items */
}

10. Animations and Transitions:

Transitions:
Smoothly changes a CSS property over a specified duration.
button {
  background-color: green;
  transition: background-color 0.3s ease; /* Changes background color smoothly */
}
button:hover {
  background-color: blue;
}

Animations:
CSS animations allow you to animate element properties using keyframes.
@keyframes slide {
  from { transform: translateX(0); }
  to { transform: translateX(100px); }
}
div {
  animation: slide 2s infinite; /* Moves element from left to right repeatedly */
}
Conclusion:
Advanced CSS syntax provides powerful tools for creating flexible, responsive, and dynamic web layouts. 
It goes beyond simple styling by allowing the manipulation of the structure, layout, and behavior of web content through combinators, pseudo-classes, pseudo-elements, media queries, and more. 
Mastering these advanced techniques gives you greater control and creative freedom in web development.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
The @keyframes rule in CSS is used to define animations. It allows you to create an animation by specifying how the style of an element changes from one state to another at various points during the animation.

Basic Syntax:
@keyframes animation-name {
  0% {
    /* Starting styles */
  }
  100% {
    /* Ending styles */
  }
}

Applying the Keyframes:
To apply the keyframes to an element, you use the animation property, which can include various parameters like the name of the animation, duration, and timing.

Example:
@keyframes slideIn {
  0% {
    transform: translateX(-100%);
    opacity: 0;
  }
  100% {
    transform: translateX(0);
    opacity: 1;
  }
}

div {
  animation: slideIn 2s ease-in-out;
}
In this example:
The keyframes rules defines an animation named slideIn.
The animation moves an element from off-screen (left) into its normal position over a 2-second duration.
The animation property is applied to the div element, using the slideIn keyframes.

Key Points:
0% and 100% represent the start and end of the animation. You can also define intermediate states like 50%.
You can define any number of keyframes by specifying percentages.
CSS properties that can be animated include opacity, transform, background-color, etc.

More Advanced Example with Multiple Keyframes:
@keyframes bounce {
  0%, 100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-50px);
  }
}
div {
  animation: bounce 1s infinite;
}
Here:
The keyframes rule defines a bounce animation.
At 50%, the element moves up by 50px, and at 0% and 100%, it returns to its original position.
The animation runs infinitely because of the infinite value in the animation shorthand.

Animation Shorthand:
The animation property allows you to define multiple aspects of the animation in one line:

animation: <animation-name> <duration> <timing-function> <delay> <iteration-count> <direction>;

For example:
animation: slideIn 2s ease-in-out 0s infinite alternate;
This defines:
slideIn as the animation name.
2s duration.
ease-in-out timing function.
0s delay.
infinite iterations (loops).
alternate direction (the animation reverses direction after each iteration).
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS animations allow you to animate the transition of CSS properties from one state to another, creating more dynamic and interactive user experiences. Animations in CSS are often implemented using the @keyframes rule to define the animation's steps, and then the animation property to apply the animation to an element.

Core Components of CSS Animations:
1. @keyframes: Defines the animation's states at various points (percentages).
2. animation property: Used to control the animation (e.g., duration, timing, etc.).
Basic Example:
@keyframes fadeIn {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
div {
  animation: fadeIn 3s ease-in-out;
}

Animation Property Shorthand:
The animation shorthand property allows you to set multiple animation properties at once. Here’s the general syntax:

animation: <name> <duration> <timing-function> <delay> <iteration-count> <direction> <fill-mode> <play-state>;

Explanation of Animation Properties:
1. animation-name: The name of the keyframes you want to apply.
animation-name: fadeIn;

2. animation-duration: How long the animation will take to complete one cycle (e.g., 2s for 2 seconds).
animation-duration: 3s;

3. animation-timing-function: Controls the speed curve of the animation. Common values:
ease (default): Starts slow, then speeds up, then slows down.
3.1 linear: Constant speed.
3.2 ease-in: Slow start.
3.3 ease-out: Slow end.
3.4 ease-in-out: Slow start and end.
3.5 animation-timing-function: ease-in-out;

4. animation-delay: Specifies a delay before the animation starts.
animation-delay: 1s;  /* Waits 1 second before starting */

5. animation-iteration-count: Number of times the animation should repeat.
1: Plays once (default).
infinite: Loops infinitely.
animation-iteration-count: infinite;

6. animation-direction: Whether the animation should play in reverse after each cycle.
normal: Plays forward (default).
reverse: Plays backward.
alternate: Plays forward first, then backward.
animation-direction: alternate;

7. animation-fill-mode: Specifies what styles should be applied to the element when the animation is not playing (before it starts or after it ends).
none: No styles are applied (default).
forwards: Keeps the final styles when the animation ends.
backwards: Applies the styles from the first keyframe during the animation delay.
both: Applies both forwards and backwards.
animation-fill-mode: forwards;

8. animation-play-state: Specifies whether the animation is running or paused.
running: Plays the animation (default).
paused: Pauses the animation.
animation-play-state: paused;

Full Example with All Properties:
@keyframes bounce {
  0% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-50px);
  }
  100% {
    transform: translateY(0);
  }
}

div {
  animation: bounce 2s ease-in-out 0s infinite alternate forwards;
}
In this example:
The bounce animation moves the element up and down.
It has a duration of 2 seconds and repeats infinitely in alternating directions.
The forwards value makes sure the final state is retained after each iteration.

Combining Multiple Animations:
You can apply multiple animations to an element by separating them with commas:
div {
  animation: bounce 2s ease-in-out, fadeIn 3s linear;
}

CSS Animation Best Practices:
Performance: Animating transform (translate, scale, rotate) and opacity is more performant than animating properties like height or left.
Timing Functions: Use ease or ease-in-out for natural motion, linear for consistent speed.
Fallbacks: Provide meaningful fallbacks for unsupported browsers (like no animation).
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS margin Property
/*-------------------------------------*/
The margin property in CSS is used to create space around elements, separating them from other elements on the page. 
It can be set for all four sides (top, right, bottom, left) of an element.
There is a horizontal and vertical scroll-bar, by setting the body default margin added by some browsers to 0 you can remove it.

Key Features:
element {
  margin: value; /* Single value for all sides */
  margin: top right bottom left; /* Individual values */
}

Common Values:
1. Length Units: Pixels (px), ems (em), rems (rem), percentages (%).
2. Auto: Automatically adjusts the margin, often used for centering.
3. Percentage: Based on the width of the containing element.

Example Values:
div {
  margin: 20px; /* 20px for all sides */
  margin: 10px 15px; /* 10px top/bottom(vertical margin), 15px left/right(horizontal margin) */
  margin: 5px 10px 15px 20px; /* top right bottom left */
  margin: 0 auto 20px; /*0 top margin, horizontal margin auto, bottom margin to 20px*/
}

Collapsing Margins:
Margins of block elements can collapse, meaning that the larger margin between two adjacent elements will be used instead of adding them together.*/

Negative Margins:
You can use negative values to pull an element closer to or overlap another element.

Usage:
Creating Space: Margins are primarily used to create space around elements, improving layout and readability.*/
Alignment: Helps in aligning elements, particularly when combined with other CSS properties like display.*/

Example:
.container {
  margin: 20px; /* Adds space around the container */
}
.item {
  margin-bottom: 15px; /* Adds space below each item */
}
.block {
  margin: -20px; /* Removes space around the block */
}
.one{
  margin:auto /*center*/
}
The margin property is crucial for layout design in CSS, allowing for control over spacing and positioning of elements.
This summary provides an overview of the margin property, its features, and its practical use in CSS.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS padding Property
/*-------------------------------------*/
The padding property in CSS is used to create space between an element's content and its border. 
It affects the inner space of an element, providing a cushion around the content.

Key Features:
element {
  padding: value; /* Single value for all sides */
  padding: top right bottom left; /* Individual values */
}

Common Values:
1. Length Units: Pixels (px), ems (em), rems (rem), percentages (%).
2. Percentage: Based on the width of the containing element.

Example Values:
div {
  padding: 20px; /* 20px padding on all sides */
  padding: 10px 15px; /* 10px top/bottom, 15px left/right */
  padding: 5px 10px 15px 20px; /* top right bottom left */
}

Non-Collapsing:
Unlike margins, padding does not collapse. The total space will always be the sum of the padding values.

Background Color:
Padding can affect the background color of an element. The background extends to the edge of the padding area.

Usage:
Creating Space: Padding is used to add space inside an element, making the content more readable and visually appealing.
Styling: Enhances the visual presentation of elements, such as buttons, by giving them a more substantial look.

Example:
.container {
  padding: 20px; /* Adds space inside the container */
  background-color: lightgray; /* Background fills the padding area */
}
.item {
  padding: 10px; /* Adds space around the content inside each item */
}
The padding property is essential for controlling the internal spacing of elements in CSS, allowing for better layout and improved design.
This summary outlines the padding property, its characteristics, and its practical applications in CSS.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS max-width and min-width Properties
/*-------------------------------------*/
The max-width and min-width properties in CSS are used to control the width of an element, ensuring it does not exceed or fall below specified limits.

Key Features:

1. max-width:
Definition: Sets the maximum width of an element. The element will not grow wider than this value, even if more space is available.
Common Values: Can be set in length units (e.g., px, em, %) or none (default).
Example:
div {
  max-width: 600px; /* Element will not exceed 600px in width */
}

2. min-width:
Definition: Sets the minimum width of an element. The element will not shrink smaller than this value, even if there is less space available.*/
Common Values: Similar to max-width, can be specified in length units or none.*/
Example:
div {
  min-width: 300px; /* Element will not be smaller than 300px in width */
}

Usage:
Responsive Design: Both properties are essential for creating flexible and responsive layouts, ensuring elements adapt to varying screen sizes while maintaining usability.*/
Content Control: Prevents content from becoming too wide or too narrow, improving readability and aesthetics.*/

Example:
.container {
  max-width: 800px; /* Limits width to 800px */
  min-width: 400px; /* Ensures width is at least 400px */
  width: 100%; /* Allows the container to take full width within limits */
}

Key Points:
Combining Values: Using both properties together helps maintain design integrity across different devices and screen sizes.*/
Responsive Units: Percentages are often used with these properties for fluid designs.*/
The max-width and min-width properties are vital in CSS for controlling element dimensions and ensuring responsive design.*/
This summary provides an overview of the max-width and min-width properties, their definitions, usage, and examples.*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS display property
/*-------------------------------------*/
The display property in CSS specifies how an element is rendered on the web page. 
It affects the layout and behavior of elements in the document.

Common Values:
1. block: The element is rendered as a block-level element, starting on a new line and taking up the full width available.
div { display: block; }

2. inline: The element is rendered as an inline element, not starting on a new line and only taking up as much width as necessary.
span { display: inline; }

3. inline-block: The element is formatted as an inline element but allows setting width and height. 
Only takes up the width of their content
To Spread the content out put elements on same line editor <p></p><p></p>, change width:% depending on characters or size, like name:75% and price:25%*/
button { display: inline-block; }

4. none: The element is not rendered at all (it takes up no space).
.hidden { display: none; }

5. flex: The element is rendered as a flex container, allowing for flexible layout with its children.
This will make the element a flex container. Any direct children of a flex container are called flex items.
.container { display: flex; }

6. grid: The element is rendered as a grid container, enabling a grid-based layout.
.grid { display: grid; }

7. table: The element is rendered as a table element.
.table { display: table; }

Example Usage:
header { display: block; }
nav { display: flex; }
footer { display: none; }

Key Points:
Block elements start on a new line and take full width.*/
Inline elements flow within text and do not start a new line.*/
Inline-block combines properties of both inline and block elements.*/
Flex and Grid enable modern responsive layouts.*/
Setting display: none completely hides the element from the document flow.*/
The display property is fundamental in CSS for controlling the layout and visual structure of web pages.*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS Text Properties
/*-------------------------------------*/
1. color: Specifies the color of the text.
element {color: color;}
p {color: #333333;}

2. font-family: Specifies the font of the text.
element {font-family: font1, font2, generic-family;}
h1 {font-family: "Arial", sans-serif;}

3. font-size: Controls the size of the text.
element {font-size: value;}
h2 {font-size: 24px;}

4. font-weight: Controls the boldness of the text.
element {font-weight: value;}
strong {font-weight: bold;}

5. font-style: Specifies whether the text is italic or normal.
element {font-style: normal | italic | oblique;}
em {font-style: italic;}

6. text-align: Aligns the text horizontally.
element {text-align: left | right | center | justify;}
p {text-align: center;}

7. text-decoration: Adds decorative lines to the text (like underline, overline, or strikethrough).
element {text-decoration: none | underline | overline | line-through;}
a {text-decoration: underline;}

8. text-transform: Controls the capitalization of text.
element {text-transform: none | capitalize | uppercase | lowercase;}
h1 {text-transform: uppercase;}

9. line-height: Sets the space between lines of text.
element {line-height: value;}
p {line-height: 1.5;}

10. letter-spacing: Controls the space between characters.
element {letter-spacing: value;}
h1 {letter-spacing: 2px;}

11. word-spacing: Controls the space between words.
element {word-spacing: value;}
p {word-spacing: 5px;}

12. text-indent: Specifies the indentation of the first line of text in a block.
element {text-indent: value;}
p {text-indent: 20px;}

13. text-shadow: Adds shadow to text.
element {text-shadow: h-shadow v-shadow blur color;}
h1 {text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);}

Example Combining Multiple Text Properties:
h1 {
  font-family: "Arial", sans-serif;
  font-size: 32px;
  color: #333;
  text-align: center;
  text-transform: uppercase;
  letter-spacing: 1px;
  text-decoration: underline;
}

Key Points:
Text styling improves the readability and visual appearance of content.
Multiple properties can be combined to create complex text effects.
The above properties are commonly used for styling text in web design to enhance readability, aesthetics, and user experience.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS font-family property
/*-------------------------------------*/
Used to specify the typeface for text within an element. 
Controls how the text is displayed, affecting its appearance and readability.*/

Key Features:
element {font-family: font1, font2, generic-family;}

Font Stack:
A list of fonts can be specified, with the browser using the first available font.

Example:
p {font-family: "Arial", "Helvetica", sans-serif; /* Uses Arial, fallback to Helvetica, then sans-serif */}

Font Types:
Specific Fonts: Custom or widely available fonts (e.g., "Times New Roman").

Generic Font Families:
serif: Fonts with decorative strokes (e.g., Times, Georgia).
sans-serif: Fonts without decorative strokes (e.g., Arial, Verdana).
monospace: Equal spacing for all characters (e.g., Courier, Lucida Console).
cursive: Imitates handwritten text (e.g., Comic Sans MS).
fantasy: Decorative fonts (e.g., Impact).

Web Fonts:
Custom fonts can be included using services like Google Fonts or Adobe Fonts for enhanced typography.

Example Usage:
body {font-family: "Roboto", sans-serif; /* Uses Roboto font with sans-serif as a fallback */}

Key Points:
Readability: Choosing the right font family improves the readability and aesthetics of text content.*/ 
Cross-Browser Compatibility: Always include a generic fallback font to ensure text displays correctly if the specified font is unavailable.*/
The font-family property is essential for defining typography in web design, enhancing the visual appeal and user experience of text.*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS font-size property
/*-------------------------------------*/
Used to control the size of the text. It allows you to set how large or small the font should appear for an element's content.
element {font-size: value;}

Common Values:

1. Absolute Size Keywords:
Predefined values for font size that are relative to the browser's default size.
Example:
font-size: small;   /* smaller than the default size */
font-size: medium;  /* default size */
font-size: large;   /* larger than the default size */

2. Relative Size Keywords:
Keywords that change size based on the current font size.
font-size: larger;  /* larger than the parent element's font size */
font-size: smaller; /* smaller than the parent element's font size */

3. Length Units:
Set specific font sizes using units like px, em, rem, %, vw, etc.

Pixels (px): Specifies a fixed size.
font-size: 16px; /* Fixed size of 16 pixels */

Ems (em): Relative to the element’s parent size.
font-size: 1.5em; /* 1.5 times the parent's font size */

Rems (rem): Relative to the root element’s font size.
font-size: 2rem; /* 2 times the root font size */

Percentages (%): Relative to the parent element’s font size.
font-size: 120%; /* 120% of the parent element's font size */

Viewport Units: Set font size relative to the viewport (e.g., vw, vh).
font-size: 2vw; /* 2% of the viewport width */

Example Usage:
p {
  font-size: 18px; /* Sets font size to 18 pixels */
}

h1 {
  font-size: 2rem; /* Sets font size to 2 times the root element's font size */
}
Key Points:
Relative Units (em, rem, %) are flexible and more responsive than fixed units like px.
Responsive Design: rem, vw, and % are commonly used in responsive design to adjust text size based on screen or parent sizes.
Default Size: The default font size for most browsers is 16px (medium).
The font-size property is crucial for controlling text size, ensuring readability, and creating scalable and responsive typography in web design.

This summary outlines the key aspects of the font-size property, with examples and common use cases.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS max() and min() functions
/*-------------------------------------*/
The max() and min() functions in CSS are powerful tools that allow developers to dynamically set values based on the larger or smaller of multiple options. 
These functions can be used for various properties (like width, height, font-size, margin, etc.), allowing for more responsive and adaptive designs without relying on media queries.

1. min() Function:
The min() function in CSS selects the smallest value from a list of values. It's useful when you want to cap a value so that it doesn’t exceed a certain limit.

Syntax:
min(value1, value2, value3, ...);

Example:
.element {
  width: min(50%, 300px);
}
In this example:
The browser will calculate both 50% of the containing element and 300px, then apply the smaller value as the width.
On smaller screens, 50% might be smaller than 300px, so that value will be used. On larger screens, 300px might be smaller than 50%, so the width will be capped at 300px.

Use Cases for min():
Responsive font sizes: Keep font size dynamic but prevent it from becoming too large.
font-size: min(4vw, 24px);
Here, the font will grow with the viewport but not exceed 24px.
Flexible layout sizes: Set widths or heights based on available space but cap them at a certain maximum size.
max-width: min(90vw, 600px);

2. max() Function:
The max() function in CSS selects the largest value from a list of values. It’s useful when you want to set a minimum value or ensure that an element doesn’t shrink too much.

Syntax:
max(value1, value2, value3, ...);

Example:
.element {
  width: max(50%, 300px);
}
In this example:
The browser will calculate both 50% of the container and 300px, then apply the larger value as the width.
On small screens, 300px might be larger than 50%, so the width will be set to 300px. On larger screens, 50% will likely be the larger value, so it will be used instead.

Use Cases for max():
Preventing elements from shrinking too much:
width: max(50%, 200px);
This ensures the element will never be smaller than 200px, even if 50% of the container is less than that.

Ensuring minimum font sizes:
font-size: max(2vw, 18px);
The font size will scale with the viewport but will never drop below 18px.

Combining min() and max() Together:
You can use both min() and max() together to create more flexible and responsive designs, controlling both the minimum and maximum values dynamically.
Example:
.element {
  width: min(max(30%, 200px), 500px);
}
max(30%, 200px): The width will be at least 200px, but if 30% of the parent container is larger than 200px, it will use that value.
min(..., 500px): The width will also be capped at a maximum of 500px, ensuring it doesn’t grow too large on big screens.

Practical Examples of min() and max():
Example 1: Dynamic Font Sizing
h1 {
  font-size: min(8vw, 48px); /* Scales with viewport but never larger than 48px */
}
The font size will scale with the viewport width (8vw), but it will stop growing once it reaches 48px.

Example 2: Controlling Layout Width
.container {
  width: max(300px, 40%); /* Ensures the container is never smaller than 300px */
}
The container will be at least 300px, but on larger screens, it will grow to 40% of the parent’s width.

Example 3: Image Scaling with Max and Min:
img {
  width: min(100%, 600px); /* Image fills container but doesn’t exceed 600px */
  height: auto;
}
The image will be responsive, filling the width of the container, but will not exceed 600px in width.

Browser Support:
The min() and max() functions are well-supported in modern browsers (Chrome, Firefox, Edge, and Safari). However, for older browsers, fallback strategies or polyfills may be required.

Conclusion:
min() is useful when you want to apply the smallest value from a set, often to prevent something from growing too large.
max() is useful when you want to apply the largest value from a set, often to ensure something doesn’t shrink too much.
Together, they provide a flexible way to handle dynamic layouts and responsive design without relying heavily on media queries.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS text-align property
/*-------------------------------------*/
Specifies the horizontal alignment of text within a block element.

Common Values:
left: /* Aligns text to the left (default). */
p { text-align: left; }

right: /* Aligns text to the right. */
p { text-align: right; }

center: /* Centers the text within the element. */
p { text-align: center; }

justify: /* Stretches text to fill the width of the element, aligning both sides. */
p { text-align: justify; }

start: /* Aligns text to the starting edge based on text direction.*/
p { text-align: start; }

end: /* Aligns text to the ending edge based on text direction.*/
p { text-align: end; }

Example Usage:
<p>This paragraph is centered.</p>
<style>
  p { text-align: center; }
</style>

Application in Tables:
th, td { text-align: center; }

Text Alignment and Languages:
LTR (left-to-right): /* left, start align to the left; right, end align to the right.*/
RTL (right-to-left): /* left, start align to the right; right, end align to the left.*/
text-align is essential for controlling text layout in web design, enhancing readability and presentation.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS Absolute Units
/*-------------------------------------*/
Units are fixed and will always be the same regardless of screen size or device.
They are usually less flexible for responsive design.
px (Pixels):       Represents a single dot on the screen. This is the most commonly used unit for defining fixed-width and height.*/
cm (Centimeters):  Size in centimeters.
mm (Millimeters):  Size in millimeters.
in (Inches):       Size in inches (1in = 2.54cm).
pt (Points):       A point is 1/72 of an inch, often used in print styles.
pc (Picas):        1 pica equals 12 points or 1/6 of an inch.

Relative Units
These units are flexible and scale relative to other values, making them more suitable for responsive design.
Relative to the viewport:
vw (Viewport Width):   1vw is 1% of the viewport's width.
vh (Viewport Height):  1vh is 1% of the viewport's height.
vmin:                  1vmin is 1% of the smaller dimension (either width or height) of the viewport.
vmax:                  1vmax is 1% of the larger dimension of the viewport.

Relative to the font size:
em:   Relative to the font-size of the current element or its parent. 
      If an element's font-size is set to 2em, it means twice the size of its parent’s font size.
rem:  Relative to the font-size of the root element (<html>). 
      For example, if the root element is set to 16px, 1rem will equal 16px.
ex:   Relative to the x-height (height of the lowercase "x") of the element's font.
ch:   Relative to the width of the "0" (zero) character in the element's font.

Grid-specific unit:
fr (Fraction):  Used in CSS Grid to allocate space in a container. For example, 1fr means 1 part of the available space, and 2fr means 2 parts.

Other Units
%:   Percentage relative to its parent element. For example, width: 50% will be half the width of its parent.

Summary Table:
Unit	Description	                                              Example
px	  Pixels, an absolute unit	                                width: 100px;
em	  Relative to the font size of the element	                font-size: 2em;
rem	  Relative to the font size of the root element	            padding: 1rem;(relative to the font size of the html element)
vw	  1% of the viewport's width	                              width: 50vw;
vh	  1% of the viewport's height	                              height: 50vh;
vmin	1% of the viewport's smaller dimension (width or height)	width: 20vmin;
vmax	1% of the viewport's larger dimension	                    width: 20vmax;
fr	  Fractional unit in CSS Grid	                              grid-template-columns: 1fr 2fr;
%	    Percentage relative to parent element	                    width: 50%;

Use px when you want the size to be fixed. 
Use rem/em when you want it to be adaptive to the scale of the system. 
For example, fonts using px wont re-scale if you change font size of the system. 
If you use rem or em their size will change which adds accessability for people that have harder to read
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS auto keyword
/*-------------------------------------*/
CSS auto keyword can be used in several contexts, where it behaves differently depending on the property. 
It is often used to allow the browser to automatically determine the value for a particular property based on the content or other factors, providing flexibility without hardcoding specific values.*/

1. Width and Height
If you set the width or height of an element to auto, the browser will automatically calculate and adjust the size based on the content.*/
div {
  width: auto;  /* The width is automatically adjusted to fit the content */
  height: auto; /* The height is automatically adjusted to fit the content */
}
Default Behavior: For block-level elements (e.g., <div>), the width is auto by default, which means it stretches to fill the container's available width. 
For inline elements (e.g., <span>), the width and height are determined by the content.*/

2. Margins
Setting margin: auto is commonly used to center block-level elements horizontally within their container.*/
div {
  width: 50%;   /* Set a fixed width */
  margin: 0 auto;  /* Center the element horizontally */
}
margin: 0 auto; centers the element by setting equal margins on both sides, as long as the element has a defined width (or max-width).

3. Positioning (top, right, bottom, left)
When using position: absolute or position: relative, the auto value allows the element to remain in its default position for that particular direction.
div {
  position: absolute;
  top: auto;    /* Allow the element to retain its default top position */
  left: auto;   /* Allow the element to retain its default left position */
}
This can be useful when combining auto with other positioning properties to maintain flexibility in layout.

4. Grid
In CSS Grid, the auto value can be used to make grid items expand or shrink depending on the available space.
.container {
  display: grid;
  grid-template-columns: auto auto 1fr; /* First two columns will automatically adjust to their content, the third column takes the remaining space */
}

5. Flexbox
In Flexbox, auto can be used for the flex-basis property. 
This value allows the flex item to size based on its content but can still grow or shrink if needed.
.flex-container {
  display: flex;
}
.flex-item {
  flex-basis: auto; /* The flex item will size itself based on content */
}

Common Scenarios for auto:
Centering an element: margin: auto (horizontal centering)
Responsive layouts: Allowing the width or height to adjust based on content with width: auto; or height: auto;
Positioning: When working with complex layouts (like absolute or fixed positioning) to let the element retain its default position.*/
<div style="width: 50%; margin: 0 auto; background-color: lightblue;">
  This div is centered!
</div>
In this example, the div will have a width of 50% of its container and be horizontally centered due to the margin: 0 auto; rule.
auto is a powerful and flexible value that makes it easier to create dynamic layouts, without having to hardcode pixel values for each case.*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS Grid
/*-------------------------------------*/
CSS Grid is a two-dimensional layout system that allows you to design complex layouts by controlling both the rows and columns of an element. 
It’s incredibly powerful and flexible, making it easy to arrange items in grids, define specific areas, and create responsive designs.

Key Concepts in CSS Grid
Grid Container: The parent element where the grid layout is applied.
Grid Items: The child elements inside the grid container.
Grid Tracks: Rows and columns that make up the grid.
Grid Lines: The horizontal and vertical dividing lines between grid cells.
Grid Cells: The individual units where grid items can be placed.
Grid Areas: Named or defined areas that span multiple cells.

Basic CSS Grid Syntax
To create a grid layout, you first define a container as a grid, and then set the number of columns and rows, as well as the positioning of the grid items.

Basic Example
.container {
  display: grid;
  grid-template-columns: 200px 1fr 200px;  /* Defines 3 columns: 200px, flexible, 200px */
  grid-template-rows: auto 300px;          /* Defines 2 rows: auto, 300px */
  gap: 10px;                               /* Defines space between rows and columns */
}
.item1 {
  grid-column: 1 / 3;                      /* Item spans columns 1 to 3 */
  grid-row: 1;                             /* Item is in the first row */
}
.item2 {
  grid-column: 2 / 4;                      /* Item spans columns 2 to 4 */
  grid-row: 2;                             /* Item is in the second row */
}

Grid Properties
1. display: grid;
This defines the container as a grid. Any direct children of this container become grid items.

2. grid-template-columns and grid-template-rows
These properties define the structure of the grid, specifying the number of columns and rows, and their sizes.
grid-template-columns defines the number and size of columns.
grid-template-rows defines the number and size of rows.

Example:
.container {
  grid-template-columns: 1fr 2fr 1fr;  /* 3 columns: 1 part, 2 parts, 1 part */
  grid-template-rows: 100px auto;      /* 2 rows: 100px fixed height, flexible height */
}

3. grid-gap (or gap)
Defines the space between rows and columns. It can be used as:
gap: Defines space between both rows and columns.
row-gap: Defines space between rows only.
column-gap: Defines space between columns only.

Example:
.container {
  gap: 10px;  /* 10px gap between rows and columns */
}

4. grid-column and grid-row
These properties control where a grid item starts and how many columns or rows it spans. 
You can define specific grid lines to control an item’s placement.

Example:
.item {
  grid-column: 1 / 3;  /* Spans from column line 1 to column line 3 */
  grid-row: 2 / 4;     /* Spans from row line 2 to row line 4 */
}

5. grid-area
This property can either name specific areas in the grid or define an item's position in terms of the start and end points of the grid lines (rows and columns).

Example:
.container {
  grid-template-areas:
    "header header header"
    "sidebar content content"
    "footer footer footer";
}

.item1 {
  grid-area: header;
}

6. grid-auto-rows and grid-auto-columns
If the number of rows or columns isn't predefined, these properties define the size of any automatically created rows or columns.

Example:
.container {
  grid-auto-rows: 100px;  /* Automatically creates rows with 100px height */
}

Grid Alignment
Grid provides powerful tools for aligning content, similar to Flexbox:

1. justify-items and align-items
These properties align grid items inside their grid cells:
justify-items: Aligns grid items horizontally within their cells.
align-items: Aligns grid items vertically within their cells.

Example:
.container {
  justify-items: center;  /* Center items horizontally */
  align-items: center;    /* Center items vertically */
}

2. justify-content and align-content
These properties align the entire grid inside the grid container:
justify-content: Aligns the grid horizontally.
align-content: Aligns the grid vertically.

Example:
.container {
  justify-content: center;  /* Center the entire grid horizontally */
  align-content: center;    /* Center the entire grid vertically */
}

Advanced Grid Features

1. Fractional Units (fr)
The fr unit in grid defines a portion of the available space. It's a flexible unit that distributes available space based on the total number of fractions.

Example:
.container {
  grid-template-columns: 1fr 2fr 1fr;  /* First and last columns take 1 part, middle takes 2 parts */
}

2. Auto-fit and Auto-fill
The auto-fit and auto-fill functions allow grid layouts to automatically create as many rows or columns as necessary to fit the available space, often used for responsive designs.

auto-fill: Fills the row or column with as many grid items as possible, leaving empty spaces if necessary.
auto-fit: Fills the row or column with as many items as possible, but collapses empty tracks if there’s extra space.

Example:
.container {
  grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));  /* Auto-fit columns, each at least 100px wide */
}

Grid vs. Flexbox
CSS Grid is for two-dimensional layouts (both rows and columns).
Flexbox is for one-dimensional layouts (either rows or columns).
Use Grid for layouts with complex, structured needs (like web page layouts), and use Flexbox for simpler layouts or when you need flexibility in a single direction (like aligning buttons in a row).

Conclusion
CSS Grid is a powerful tool for creating complex and responsive web layouts. 
By mastering the grid properties, you can control every aspect of layout placement and design with precision, making it a go-to tool for modern web design.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/

The minmax() function in CSS Grid Layout is used to define a size range for grid tracks (columns or rows), setting both a minimum and a maximum value. This is useful when you want to ensure that a grid track has a flexible size but remains within certain boundaries.

Syntax:
minmax(min, max)
min: The minimum size of the grid track. It can be a length value (e.g., 100px), percentage (e.g., 30%), or a flexible unit like auto.
max: The maximum size of the grid track. It can also be a length value, percentage, or flexible unit like 1fr (fractional unit).

Use Cases
Flexible grids: You can use minmax() to ensure that grid items are responsive, growing or shrinking within specified limits.
Automatic layouts: It can allow the grid items to take up more space as available, but never below or above a certain limit.

Example 1: Resizable Columns
In this example, each column will have a minimum size of 100px, but it can grow to take up available space with a maximum size of 1fr (fraction of remaining space).
.container {
  display: grid;
  grid-template-columns: minmax(100px, 1fr) minmax(200px, 2fr);
}
This creates two columns where:
The first column is at least 100px wide but can grow to take up available space.
The second column is at least 200px wide and grows twice as much as the first column.

Example 2: Limiting Growth with auto and minmax
.container {
  display: grid;
  grid-template-columns: repeat(3, minmax(150px, auto));
}
This grid will have three columns, each with a minimum width of 150px, and the maximum width depends on the content but can grow larger than 150px.

Summary
The minmax() function is ideal for creating responsive, flexible grid layouts where elements adapt to the viewport size, but within a controlled range.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
The grid-auto property in CSS is used in the context of CSS Grid Layout. It defines how grid items are automatically placed in a grid when there are more items than explicitly defined columns or rows. The grid-auto properties include grid-auto-rows, grid-auto-columns, and grid-auto-flow.

Here’s a breakdown:

1. grid-auto-rows: Defines the size of the implicitly created rows when items are placed outside the defined grid template rows.
grid-auto-rows: 100px;

2. grid-auto-columns: Defines the size of the implicitly created columns when items are placed outside the defined grid template columns.
grid-auto-columns: 100px;

3. grid-auto-flow: Controls how items are automatically placed in the grid. It can have several values:
row: Places items by filling rows first (default).
column: Places items by filling columns first.
dense: Tries to fill in gaps in the grid, even if it means reordering items.
Example:
grid-auto-flow: row dense;

Example:
.container {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  grid-auto-rows: 150px;
  grid-auto-flow: column;
}
In this example, any additional grid items will create new rows, each 150px high, and the items will be filled in a column-first order.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS Flexbox
/*-------------------------------------*/
Flexbox (Flexible Box Layout) is a CSS layout model that allows for a more efficient way to design complex layouts and align elements within a container. 
It is particularly useful for creating responsive layouts that adapt to different screen sizes and orientations.

Key Concepts of Flexbox:
Flexbox operates on two axes:
Main Axis: Defined by the flex-direction property (can be horizontal or vertical).
Cross Axis: Perpendicular to the main axis.
The container is known as the flex container, and the items inside it are called flex items.

Flexbox Properties:
For Flex Container:

1. display: flex; or display: inline-flex;:
This defines a flex container. All direct children of this container become flex items.
display: flex is for creating a block-level flex container that takes up the full width of its container and appears on its own line.
display: inline-flex creates an inline-level flex container, allowing other elements to be positioned next to it while still using the Flexbox model to layout its children.

Example:
.container {
  display: flex;
}
.container {
  display: inline-flex;
}

2. flex-direction:
Defines the direction of the flex items in the flex container.
Values: row (default), row-reverse, column, column-reverse.
row: Lays items horizontally (left to right).
row-reverse: Lays items horizontally (right to left).
column: Lays items vertically (top to bottom).
column-reverse: Lays items vertically (bottom to top).

Example:
.container {
  flex-direction: row; /* Items flow horizontally from left to right */
}

3. justify-content:
Aligns flex items along the main axis (horizontally for row and row-reverse, vertically for column and column-reverse).
The justify-content property determines how the items inside a flex container are positioned along the main axis, affecting their position and the space around them.
Values: flex-start (default), flex-end, center, space-between, space-around, space-evenly.

Main Axis:
In a flex container with flex-direction: row, the main axis is horizontal (left to right).
In a flex container with flex-direction: column, the main axis is vertical (top to bottom).

Common Values:
flex-start: Aligns items to the start of the main axis.
flex-end: Aligns items to the end of the main axis.
center: Centers items along the main axis.
space-between: Distributes items evenly, with the first item at the start and the last item at the end.
space-around: Distributes items evenly, with space around each item.
space-evenly: Distributes items with equal space between them.

Example:
.container {
  justify-content: center; /* Items are centered along the main axis */
}
.container {
  justify-content: space-between; /* Lines are evenly spaced along the main axis */
}

4. align-items:
Aligns flex items along the cross axis (perpendicular to the main axis).
The align-items property positions the flex content along the cross axis. 
In this case, with your flex-direction set to row, your cross axis would be vertical.
Values: stretch (default), flex-start, flex-end, center, baseline.

Example:
.container {
  align-items: center; /* Items are aligned at the center along the cross axis */
}

5. align-content:
Aligns flex lines along the cross axis when there is extra space in the container. 
Used only when there are multiple lines of flex items.
Values: stretch (default), flex-start, flex-end, center, space-between, space-around.

Cross Axis:
In a flex container with flex-direction: row, the cross axis is vertical (top to bottom).
In a flex container with flex-direction: column, the cross axis is horizontal (left to right).

Common Values:
flex-start: Aligns lines to the start of the cross axis.
flex-end: Aligns lines to the end of the cross axis.
center: Centers lines along the cross axis.
space-between: Distributes lines evenly, with the first line at the start and the last line at the end.
space-around: Distributes lines evenly, with space around each line.
stretch: Stretches the lines to fill the container (default value).

Example:
.container {
  align-content: space-between; /* Lines are evenly spaced along the cross axis */
}

6. flex-wrap:
Controls whether flex items should wrap onto multiple lines if necessary.
The flex-wrap property determines how your flex items behave when the flex container is too small. 
Setting it to wrap will allow the items to wrap to the next row or column. nowrap (default) will prevent your items from wrapping and shrink them if needed.
Values: nowrap (default), wrap, wrap-reverse.

Example:
.container {
  flex-wrap: wrap; /* Flex items wrap onto multiple lines */
}

For Flex Items:

1. flex-grow:
Defines how much a flex item should grow relative to the rest of the flex items if there's extra space available in the container.
Example:
css
Copy code
.item {
  flex-grow: 1; /* The item will grow to fill the available space */
}

2. flex-shrink:
Defines how much a flex item should shrink relative to the other items if the container is smaller than the items.
Example:
css
Copy code
.item {
  flex-shrink: 1; /* The item will shrink if necessary */
}

3. flex-basis:
Specifies the initial size of a flex item before any available space is distributed (similar to width but flexible).

Example:
.item {
  flex-basis: 200px; /* Item has a base size of 200px */
}

4. align-self:
Allows an individual flex item to be aligned differently than the other flex items along the cross axis.
Values: auto (default), flex-start, flex-end, center, baseline, stretch.

Example:
.item {
  align-self: flex-end; /* This item aligns to the end of the container */
}

5. order:
Specifies the order in which flex items are laid out in the flex container. 
Items have a default order of 0, but this can be changed to any positive or negative value.

Example:
.item {
  order: 2; /* This item will appear second */
}

Flexbox Example:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flexbox Example</title>
  <style>
    .container {
      display: flex;
      flex-direction: row;
      justify-content: space-around;
      align-items: center;
      height: 200px;
      background-color: lightgray;
    }
    .item {
      width: 100px;
      height: 100px;
      background-color: lightblue;
      text-align: center;
      line-height: 100px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="item">Item 1</div>
    <div class="item">Item 2</div>
    <div class="item">Item 3</div>
  </div>
</body>
</html>
Explanation:
The .container is a flex container, and the .item elements are the flex items.
justify-content: space-around; spaces the items evenly along the main axis (horizontally in this case).
align-items: center; vertically centers the items along the cross axis.

Advantages of Flexbox:
Responsive design: Flexbox adjusts to screen size changes and is highly suited for responsive layouts.
Simplifies complex layouts: Aligning items both horizontally and vertically is easier compared to older layout methods.
Predictable behavior: Flexbox provides better control over space distribution and element alignment.
Flexbox vs. Other Layout Models:
Flexbox is perfect for laying out items in one-dimensional space (either row or column).
For more complex, grid-like structures (both row and column simultaneously), CSS Grid might be a better option.

Summary:
Flexbox makes it easy to align and distribute space among items in a container.
Key properties include flex-direction, justify-content, align-items, and flex-wrap.
It is very useful for responsive and flexible layouts in web design.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS Selectors 
/*-------------------------------------*/
Selectors are patterns used to select and style HTML elements. 
Selectors define which part of the document tree to apply CSS styles to. 
There are various types of CSS selectors, ranging from basic to advanced, that give you fine control over styling your content.

1. Basic Selectors
These selectors target elements by their name, class, or ID.

Universal Selector (*)
Selects all elements in the document.
* {margin: 0;padding: 0;}

Type Selector (Element Selector)
Targets elements by their tag name.
p {color: blue;}

Class Selector (.)
Selects elements with a specific class attribute.
.example {font-size: 20px;}

ID Selector (#)
Selects an element with a specific ID.
#header {background-color: lightgray;}

2. Grouping Selector
Used to group multiple selectors that share the same style rules.

Grouping Selector (,)
Applies the same style to multiple elements.
h1, h2, h3 {font-family: Arial, sans-serif;}

3. Attribute Selectors
These selectors target elements based on their attributes.

[attribute] Selector
Selects elements with a specific attribute.
input[type="text"] {border: 1px solid black;}

[attribute="value"] Selector
Selects elements with a specific attribute value.
a[href="https://example.com"] {color: green;}

[attribute^="value"] (Starts with)
Selects elements where the attribute value begins with a specified value.*/
a[href^="https"] {color: blue;}

[attribute$="value"] (Ends with)
Selects elements where the attribute value ends with a specified value.
a[href$=".pdf"] {color: red;}

[attribute="value"] (Contains)*
Selects elements where the attribute value contains a specified substring.
a[href*="example"] {color: orange;}

CSS Attribute Selectors
CSS attribute selectors allow you to target HTML elements based on the presence or value of their attributes. 
This is particularly useful for applying styles to elements with specific attributes, such as class, id, type, href, data-*, and more. 
They provide more flexibility and precision than basic selectors.

Attribute selectors are written with square brackets [].
They allow a range of operations such as checking if an element has an attribute, if the attribute value matches exactly, or if the value starts, ends, or contains a specific substring.

Deep Dive into the various types of attribute selectors:

1. [attribute] Selector
Purpose: Targets elements that have a particular attribute, regardless of its value.
Syntax:
[attribute] {
  styles
}
[disabled] {
  opacity: 0.5;
}
This will select all elements that have the disabled attribute (e.g., form elements), regardless of the value of disabled.

2. [attribute="value"] Selector
Purpose: Selects elements where the attribute matches a specific value exactly.
Syntax:
[attribute="value"] {
  styles
}
[type="text"] {
  border: 1px solid black;
}
This applies styles to all input elements where type="text" (e.g., <input type="text">).

3. [attribute^="value"] Selector (Starts With)
Purpose: Targets elements where the attribute value begins with a specific string.
Syntax:
[attribute^="value"] {
  styles
}
[class^="btn-"] {
  padding: 10px;
}
This applies to all elements with a class name that starts with btn-, such as btn-primary or btn-secondary.
Use Cases:
Ideal for situations where elements share a common prefix in their class or attribute value, such as button types (btn-primary, btn-secondary).

4. [attribute$="value"] Selector (Ends With)
Purpose: Selects elements where the attribute value ends with a specific string.
Syntax:
[attribute$="value"] {
  styles
}
[href$=".pdf"] {
  color: red;
}
This applies styles to all anchor (<a>) elements with an href that ends in .pdf, which is useful for targeting links to PDF files.
Use Cases:
Useful for targeting elements based on file types in URLs (e.g., .jpg, .pdf) or other attributes that use specific suffixes.

5. [attribute="value"] Selector (Contains)*
Purpose: Targets elements where the attribute value contains a specific substring.
Syntax:
[attribute*="value"] {
  styles
}
[class*="menu"] {
  font-weight: bold;
}
This applies styles to any element whose class attribute contains the substring menu, like main-menu or sidebar-menu.
Use Cases:
Useful for partial matches in class names, IDs, or custom attributes (e.g., elements related to a common feature).

6. [attribute~="value"] Selector (Space-separated list)
Purpose: Targets elements where the attribute value contains a specific word in a space-separated list of words. The word must match exactly.
Syntax:
[attribute~="value"] {
  styles
}
[class~="active"] {
  color: green;
}
This will apply to any element with class="active" or where active is one of multiple classes in a space-separated list (e.g., class="btn active large").
Use Cases:
Primarily used for targeting individual class names when an element has multiple classes. It is common when using utility classes in frameworks like Bootstrap or Tailwind CSS.

7. [attribute|="value"] Selector (Hyphen-separated list)
Purpose: Selects elements where the attribute value is exactly the value or starts with the value followed by a hyphen (-), typically used for language codes or similar patterns.
Syntax:
[attribute|="value"] {
  styles
}
[lang|="en"] {
  font-style: italic;
}
This applies styles to any element with a lang attribute that is either exactly en (for English) or begins with en- (e.g., en-US, en-UK).
Use Cases:
Frequently used for language attributes (lang="en-US", lang="fr-CA") or other contexts where hyphenated attribute values follow a base prefix.

8. Case-Insensitive Attribute Selector
Purpose: Allows you to perform case-insensitive matches for attributes.
Syntax:
[attribute="value" i] {
  styles
}
The i at the end makes the comparison case-insensitive.
Example:
[type="email" i] {
  color: blue;
}
This applies styles to elements with a type attribute value of email, regardless of whether it’s written as email, EMAIL, or any other case variation.

Use Cases:
Useful when you want to be flexible with attribute matching, especially in cases where attribute values may vary in capitalization.

Combining Attribute Selectors
Attribute selectors can be combined with other selectors (like class or type selectors) for more specific targeting.
input[type="text"][disabled] {
  background-color: lightgray;
}
This applies to <input> elements that have both type="text" and the disabled attribute.

Common Use Cases for Attribute Selectors:

1. Forms: Styling input fields based on type (e.g., type="text", type="password", type="checkbox") for consistent form design.
input[type="password"] {
  border: 2px solid red;
}
2. External Links: Highlighting or styling links to specific file types or external websites (e.g., links to .pdf files or target="_blank").
a[target="_blank"] {
  text-decoration: underline;
}
3. State-based Styling: Targeting disabled, required, or checked form elements.
input[required] {
  border: 1px solid orange;
}
4. Custom Data Attributes: Targeting elements based on custom data-* attributes for JavaScript interactions or content.
[data-role="admin"] {
  color: red;
}

Attribute Selector Specificity
Attribute selectors have the same specificity as class selectors. They add 10 to the specificity score, making them more specific than type selectors but less specific than ID selectors.
[class*="btn"] { }
This has the same specificity as a regular class selector like .btn.

Performance Considerations
Although attribute selectors are powerful, they can sometimes be less performant than class or ID selectors, especially if overused in complex pages. 
Use them wisely in performance-critical situations, especially when dealing with a large number of elements.

Conclusion
Attribute selectors provide a flexible way to target elements based on the presence and values of attributes. 
They are essential for more complex, responsive, and interactive designs, especially in forms, navigation links, and custom data attributes. Understanding the full range of attribute selectors and their use cases will give you precise control over your CSS styles, making your code more modular and easier to maintain.



4. Pseudo-classes
Pseudo-classes select elements based on their state or position in the document tree.

:visited
Applies style when the user visited the link
a:visited{color:black;}

:hover
Applies styles when the user hovers over the element.
a:hover {text-decoration: underline;color: brown;}

:active
Applies style when the user is clicking the link
a:active {color: brown;}

:nth-child(n)
Selects the nth child of an element.
tr:nth-child(2) {background-color: lightblue;}

:first-child, :last-child
Selects the first or last child of a parent element.
p:first-child {font-weight: bold;}

:focus
Selects an element when it has focus (e.g., when a user clicks on an input field).
input:focus {outline: 2px solid blue;}

:not(selector)
Selects elements that do not match a specific selector.
p:not(.highlight) {color: gray;}

5. Pseudo-elements
Pseudo-elements allow you to style parts of an element, such as the first letter, the first line, or before/after an element's content.

::before
Inserts content before the element’s content.
p::before {content: "Note: ";font-weight: bold;}

::after
Inserts content after the element’s content.
The ::after pseudo-element creates an element that is the last child of the selected element. 
You can use it to add an empty element after the last image. 
If you give it the same width as the images it will push the last image to the left when the gallery is in a two-column layout. 
.container::after {
  content: "";
  width: 860px;
}
p::after {content: " (end)";color: red;}

::first-letter
Selects and styles the first letter of an element.
p::first-letter {
  font-size: 2em;
  color: green;
}

6. Combinator Selectors
These selectors target elements based on their relationship to other elements.

Descendant Selector ( )
Selects all elements that are descendants of a specified element.
div p {
  color: blue;
}

Child Selector (>)
Selects all elements that are direct children of a specified element.
div > p {
  color: red;
}

Adjacent Sibling Selector (+)
Selects an element that is directly adjacent to another element.
h2 + p {
  margin-top: 0;
}

General Sibling Selector (~)
Selects all sibling elements after a specified element.
h2 ~ p {
  color: green;
}

7. Advanced Selectors

element:last-of-type
Select the last element of a specific type within a parent.

:nth-of-type(n)
Selects the nth element of its type in its parent.
p:nth-of-type(2) {
  color: purple;
}

:only-child
Selects an element if it is the only child of its parent.
div p:only-child {
  color: blue;
}

:empty
Selects elements that have no children (including text nodes).
div:empty {
  display: none;
}

Example of Combining Selectors
Select all <p> elements inside <div> elements
div p {
  color: blue;
}

Select only the first <p> element inside a <div>
div > p:first-child {
  font-weight: bold;
}

Select all <p> elements that are the second child of their parent
p:nth-child(2) {
  color: red;
}
Understanding CSS selectors is crucial for applying styles efficiently and targeting the correct elements in your HTML document.*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS color and background-color properties 
/*-------------------------------------*/
Used to style different aspects of an element's appearance: 

color:
The color property sets the text color of an element.
p {
  color: blue;
}
This would make the text inside a paragraph (<p>) blue.

background-color:
The background-color property sets the background color of an element.
div {
  background-color: yellow;
}
This would make the background of a div element yellow.

Key Differences:
color affects the text or foreground elements. */
background-color affects the background area behind the text or other content. */
Both properties accept the same types of color values, such as color names (blue, yellow), hexadecimal codes (#FF5733), RGB/RGBA, HSL, etc. */
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
RGB Model
/*-------------------------------------*/
The main RGB colors refer to the primary colors of light, which are Red, Green, and Blue. 
In the RGB color model, all other colors are created by mixing these three colors in different intensities. 
Each RGB color can have a value between 0 and 255.

Primary Colors in RGB:
Red (rgb(255, 0, 0))
Green (rgb(0, 255, 0))/ Green color key word darker green rgb(0,127,0)
Blue (rgb(0, 0, 255))

Key Combinations in RGB:
By mixing the primary colors, we get additional key colors:
Yellow (rgb(255, 255, 0)) — Red + Green
Cyan (rgb(0, 255, 255)) — Green + Blue
Magenta (rgb(255, 0, 255)) — Red + Blue
White (rgb(255, 255, 255)) — Red + Green + Blue (all maxed out)
Black (rgb(0, 0, 0)) — No color (all set to zero)

RGB Color Table:
Color	        RGB Value
White	        rgb(255, 255, 255) (Default background-color)
Black	        rgb(0, 0, 0)

Primary Colors:
Red	          rgb(255, 0, 0)
Green	        rgb(0, 255, 0)
Blue	        rgb(0, 0, 255)

Secondary Colors:
Yellow	      rgb(255, 255, 0)
Cyan          rgb(0, 255, 255) (aka Aqua)
Magenta	      rgb(255, 0, 255) (aka Fuchsia)

Tertiary Colors:
Orange        rgb(255, 127, 0) Red + Yellow
Spring Green  rgb (0, 255, 127) Cyan + Green
Violet	      rgb(127, 0, 255) Magenta + Blue
Chartreuse    rgb(127, 255, 0) Green + Yellow
Azure         rgb(0, 127, 255) Blue + Cyan
Rose          rgb(255, 0, 127) Red + Magenta (Bright Pink)

Gold          rgb(255,215,0)
Pale Gold     rgb(238,232,170)
Grey          rgb(127,127,127)
Silver        rgb (192,192,192)

These are the essential RGB colors from which all other colors are derived by adjusting the intensity of red, green, and blue values.

Complimentary Colors = opposite from each other
Combined Create Grey/ Placed Side-by-Side produce strong visual contrast (can be distracting if overused)
Better Practice = Choose one dominant color and use its complimentary color as an accent to bring attention to certain content on page, like black and red
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
Hex Model
/*-------------------------------------*/
The hex color model (or hexadecimal color codes) is a way to represent colors in web development using the RGB color model. 
In the hex color model, colors are specified as a six-digit combination of numbers and letters, where each two-digit pair represents the intensity of red, green, and blue.

Hexadecimal, or base 16 values, go from 0 - 9, then A - F:
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F

Hex Color Code Format:
#RRGGBB
RR: Represents the red component (00 to FF)
GG: Represents the green component (00 to FF)
BB: Represents the blue component (00 to FF)

Explanation:
Each two-character hexadecimal number is a value between 00 and FF (hexadecimal notation for values 0 to 255 in decimal).
The value 00 means no intensity of the color, and FF means full intensity.

Examples of Hex Colors:
Black: #000000 No red, green, or blue (total absence of color).
White: #FFFFFF Full intensity of red, green, and blue (maximum brightness).
Red: #FF0000 Full intensity of red, no green or blue.
Green: #00FF00 Full intensity of green, no red or blue.
Blue: #0000FF Full intensity of blue, no red or green.
Yellow: #FFFF00 Full red and green, no blue (mix of red and green creates yellow).
Cyan: #00FFFF Full green and blue, no red.
Magenta: #FF00FF Full red and blue, no green.

Shortened Hex Codes:
If both characters of each color component are the same (like #FFFFFF), you can write the code in shorthand form with three characters:
White: #FFF
Black: #000
Red: #F00
Green: #0F0
Blue: #00F

How the Hex Model Relates to RGB:
Each hex pair corresponds to an 8-bit value (0–255) in the RGB model. For instance:

#FF0000 is equivalent to rgb(255, 0, 0) for red.
Hex Code Example in CSS:
body {
  background-color: #FF5733; /* A shade of orange */
  color: #333333; /* Dark gray text */
}
The hex color model is widely used in web design to define colors because it’s compact and precise.

Color Name	  Hex Code	RGB Equivalent
Black	        #000000	  rgb(0, 0, 0)
White	        #FFFFFF	  rgb(255, 255, 255)

Primary Colors:
Red	          #FF0000	  rgb(255, 0, 0)
Green	        #00FF00	  rgb(0, 255, 0)
Blue	        #0000FF	  rgb(0, 0, 255)

Secondary Colors:
Yellow	      #FFFF00	  rgb(255, 255, 0)
Cyan	        #00FFFF	  rgb(0, 255, 255)
Magenta	      #FF00FF	  rgb(255, 0, 255)

Tertiary Colors:
Orange	      #FF7F00	  rgb(255, 127, 0)
Spring Green  #00FF7F   rgb (0, 255, 127)
Violet	      #7F00FF   rgb(127, 0, 255)
Chartreuse    #7FFF00   rgb(127, 255, 0)
Azure         #007FFF   rgb(0, 127, 255)
Rose          #FF007F   rgb(255, 0, 127)

Gray	        #808080	  rgb(128, 128, 128)
Dark Gray	    #A9A9A9	  rgb(169, 169, 169)

Purple	      #800080	  rgb(128, 0, 128)
Pink	        #FFC0CB	  rgb(255, 192, 203)
Brown	        #A52A2A	  rgb(165, 42, 42)
Lime	        #00FF00	  rgb(0, 255, 0)
Teal	        #008080	  rgb(0, 128, 128)
Navy	        #000080	  rgb(0, 0, 128)

More Examples:
Light Gray: #D3D3D3 → rgb(211, 211, 211)
Dark Red: #8B0000 → rgb(139, 0, 0)
Sky Blue: #87CEEB → rgb(135, 206, 235)
Light Green: #90EE90 → rgb(144, 238, 144)
Gold: #FFD700 → rgb(255, 215, 0)
Turquoise: #40E0D0 → rgb(64, 224, 208)
Coral: #FF7F50 → rgb(255, 127, 80)
Tomato: #FF6347 → rgb(255, 99, 71)
Violet: #EE82EE → rgb(238, 130, 238)
Indigo: #4B0082 → rgb(75, 0, 130)
/*-------------------------------------*/
/*-------------------------------------*/
/*-------------------------------------*/
/*-------------------------------------*/
/*-------------------------------------*/
HSL Model
/*-------------------------------------*/
The HSL color model, or hue, saturation, and lightness, is another way to represent colors.
The CSS hsl function accepts 3 values: 
a number from 0 to 360 for hue 
a percentage from 0 to 100 for saturation
a percentage from 0 to 100 for lightness

If you imagine a color wheel, the hue red is at 0 degrees, green is at 120 degrees, and blue is at 240 degrees.
Saturation is the intensity of a color from 0%, or gray, to 100% for pure color. You must add the percent sign % to the saturation and lightness values.
Lightness is how bright a color appears, from 0%, or complete black, to 100%, complete white, with 50% being neutral.

HSL Format:
hsl(H, S%, L%)
H: Hue in degrees (0–360)
S: Saturation as a percentage (0%–100%)
L: Lightness as a percentage (0%–100%)

Examples of HSL Colors:
Red: hsl(0, 100%, 50%)
Green: hsl(120, 100%, 50%)
Blue: hsl(240, 100%, 50%)
Gray (with no saturation): hsl(0, 0%, 50%) 
Light Pink (a light and desaturated red): hsl(0, 100%, 85%)
Dark Cyan (dark and fully saturated cyan):hsl(180, 100%, 25%)

HSL Color Breakdown:
Hue (H): Defines the type of color (red, green, blue, etc.) by positioning it on a color wheel.
0° = Red
60° = Yellow
120° = Green
180° = Cyan
240° = Blue
300° = Magenta
Saturation (S): Refers to how vivid or dull the color is.
100% = Fully saturated (vivid color)
0% = Gray (no color)
Lightness (L): Defines how light or dark the color is.
0% = Black
50% = Pure color (neither too dark nor too light)
100% = White

CSS HSL Example:
p {
  color: hsl(210, 50%, 60%); /* A soft blue color */
  background-color: hsl(120, 100%, 75%); /* Light green background */
}
HSL Advantages:
More intuitive: Describes colors in terms of hue, lightness, and saturation, which are closer to how we think about colors.
Easier color adjustments: Lightness and saturation can be adjusted separately from the hue, allowing for easier creation of tints, shades, and tones.
/*-------------------------------------*/
/*-------------------------------------*/
/*-------------------------------------*/
/*-------------------------------------*/
/*-------------------------------------*/
CSS linear-gradient function
/*-------------------------------------*/
A color transition, or gradient, on an element.
A gradient is when one color transitions into another. 
The CSS linear-gradient function lets you control the direction of the transition along a line, and which colors are used.

One thing to remember is that the linear-gradient function actually creates an image element, and is usually paired with the background property which can accept an image as a value.
Important Change:
background-color -> background

Example Syntax: 
div{
background: linear-gradient(gradientDirection, color1, color2, ...);
}
gradientDirection is the direction of the line used for the transition. 90deg=Horizontal 180Deg=Vertical
color1 and color2 are color arguments, which are the colors that will be used in the transition itself.
Needs at least or a minimum of two color arguments to work but can accept many colors
These can be any type of color, including color keywords, hex, rgb, or hsl.
If no gradientDirection argument is provided to the linear-gradient function, it arranges colors from top to bottom, or along a 180 degree line, by default.

background-image: linear-gradient(direction, color-stop1, color-stop2, ...);
1. Direction/Angle: This specifies the direction in which the gradient line is drawn. It can be a keyword (e.g., to right, to bottom left) or an angle (e.g., 45deg).
2. Color-stops: These are the colors used in the gradient. You can also specify how much space each color occupies in the gradient by adding percentage values after each color.
3. Parameters:
direction (optional): Defines the angle or starting point for the gradient. It determines the direction in which the gradient line moves.
Angle: You can specify an angle like 45deg, 90deg, etc.
0deg: Gradient goes from top to bottom.
90deg: Gradient goes from left to right.
180deg: Gradient goes from bottom to top.
45deg: Gradient starts from the top-left and ends at the bottom-right.
2. Keywords: You can also use directional keywords like:
to top: Gradient starts at the bottom and ends at the top.
to bottom (default): Gradient starts at the top and ends at the bottom.
to left: Gradient starts on the right and ends on the left.
to right: Gradient starts on the left and ends on the right.
Diagonal keywords: to top left, to bottom right, etc.

.RedgGreenBlue {
  background: linear-gradient(90deg, rgb(255, 0, 0), rgb(0, 255, 0),rgb(0, 0, 255));
}

Color-stops allow you to fine-tune where colors are placed along the gradient line. 
They are a length unit like px or percentages that follow a color in the linear-gradient function.
The first color is at the start (0%), the second is in the middle (50%), and the last is at the end (100%) of the gradient line.
The linear-gradient function automatically calculates these values for you, and places colors evenly along the gradient line by default

Example Syntax: 
linear-gradient(90deg, red 90%, black);
.red {
  background: linear-gradient(90deg, rgb(255, 0, 0)75%, rgb(0, 255, 0), rgb(0, 0, 255));
}
Gradient transitions often gradually change from one color to another. When a more abrupt change is required, the transition can be made with a hard stop like this:
Example Code
linear-gradient(
  var(--first-color) 0%,
  var(--first-color) 40%,
  var(--second-color) 40%,
  var(--second-color) 80%
);

Repeating Linear Gradients
The repeating-linear-gradient() function allows you to create repeating gradient patterns.

Example of a repeating gradient:
background: repeating-linear-gradient(to right, red 0%, yellow 20%, green 40%);

This will repeat the gradient pattern (red to yellow to green) across the element, restarting after every 40%.
This will make the four colors of your gradient repeat until it gets to the bottom of the element; giving you some stripes, and saving you from having to add a bunch of elements to create them.
repeating-linear-gradient(
  var(--first-color) 0%,
  var(--first-color) 40%,
  var(--second-color) 40%,
  var(--second-color) 80%
);

Opacity in Gradients
You can also use colors with transparency by using rgba() or hsla() color formats.

Example with transparency:
background: linear-gradient(to bottom, rgba(255, 0, 0, 0.5), rgba(0, 0, 255, 0.5));
This creates a gradient that transitions from semi-transparent red to semi-transparent blue.

Radial Gradient
A radial gradient in CSS is a type of gradient that radiates outwards from a central point, rather than in a linear fashion like a linear gradient. The gradient can either form circles or ellipses, and you can define how the colors transition from the center to the outer edges.

Syntax of radial-gradient()
background: radial-gradient([shape] [size] at [position], color-stop1, color-stop2, ...);
shape: Defines whether the gradient is circular or elliptical. It can be circle or ellipse. If omitted, the default is ellipse.
size: Specifies the size of the gradient. It can be closest-side, farthest-side, closest-corner, or farthest-corner. These describe how the gradient reaches its boundaries relative to the element.
position: Defines the starting point of the gradient (the center by default). You can specify this with keywords like top, center, bottom right, or specific positions such as 50% 50%.
color-stops: Similar to linear gradients, color stops define where each color starts and ends, and how the gradient blends between them.

Color Stops:
The color stops in radial gradients work the same way as in linear gradients, allowing you to specify the transition points between colors, and you can optionally define percentages to control where each color stop occurs.

Radial Gradient Example 1: Simple Circular Gradient
background: radial-gradient(circle, red, yellow, green);
This creates a radial gradient that:
Starts with red at the center.
Gradually transitions to yellow.
Ends with green at the outer edge of the element. Since the shape is circle, the gradient radiates outwards in a circular fashion.

Radial Gradient Example 2: Elliptical Gradient
background: radial-gradient(ellipse, red, yellow, green);
This creates an elliptical gradient where the colors transition from red to yellow to green. Since no position or size is specified, it will use the default values (an ellipse that stretches to the edges of the element).

Radial Gradient Example 3: Specifying Size
background: radial-gradient(circle closest-side, red, yellow, green);
circle: Specifies that the gradient is circular.
closest-side: Means the gradient will end at the side closest to the center (e.g., the shortest distance from the center to any side of the element).
This ensures that the circular gradient fits tightly into the smallest dimension of the container (e.g., if the element is rectangular, the gradient will fit within the height if it's shorter).

Radial Gradient Example 4: Positioning the Gradient
background: radial-gradient(circle at top left, red, yellow, green);
at top left: Specifies that the center of the gradient is at the top-left corner of the element.
The colors will radiate from this corner outward.

Radial Gradient Example 5: Using Percentages for Color Stops
background: radial-gradient(circle, red 10%, yellow 40%, green 100%);
In this case:
Red occupies the first 10% of the gradient.
The transition from yellow starts at 10% and ends at 40%.
Green fills the remaining space, from 40% to 100%.
This creates a more controlled color transition where the colors stop and blend at specific points.

Radial Gradient Example 6: Repeating Radial Gradient
CSS also allows for repeating radial gradients using the repeating-radial-gradient() function, which repeats the pattern indefinitely.
background: repeating-radial-gradient(circle, red, yellow 10%, green 20%);
In this example:
The pattern repeats, alternating between red, yellow, and green every 20% of the radius.
Radial Gradient Size Keywords:
closest-side: The gradient will extend from the center to the side closest to it, either horizontally or vertically (whichever is smaller).
farthest-side: The gradient will extend from the center to the side farthest from it, either horizontally or vertically (whichever is larger).
closest-corner: The gradient will extend from the center to the nearest corner of the element.
farthest-corner: The gradient will extend from the center to the farthest corner of the element (default).

Example 7: Radial Gradient with Different Sizes and Shapes
background: radial-gradient(ellipse farthest-corner at center, red, yellow, green);
ellipse: The gradient will take an elliptical shape.
farthest-corner: The gradient will extend to the farthest corner of the element.
at center: The gradient's center will be positioned in the middle of the element.


/*-------------------------------------*/
/*-------------------------------------*/
/*-------------------------------------*/
/*-------------------------------------*/
/*-------------------------------------*/
Opacity
/*-------------------------------------*/
Opacity describes how opaque, or non-transparent, something is. 
For example, a solid wall is opaque, and no light can pass through. 
But a drinking glass is much more transparent, and you can see through the glass to the other side.
With the CSS opacity property, you can control how opaque or transparent an element is. 
With the value 0, or 0%, the element will be completely transparent, and at 1.0, or 100%, the element will be completely opaque like it is by default.
opacity:1;

Another way to set the opacity for an element is with the alpha channel. 
Similar to the opacity property, the alpha channel controls how transparent or opaque a color is.
To add an alpha channel to an rgb color, use the rgba function instead.

Example Syntax:
element {
  opacity: value;
}
value: A number between 0 and 1, where:
0 means fully transparent (invisible).
1 means fully opaque (completely visible).
Values between 0 and 1 represent varying levels of transparency.
0.5 means 50% transparent.
0.75 means 75% opaque (25% transparent).
div {
  opacity: 0.5; /* 50% transparent */
}


rgba{
 background-color: rgba(redValue, greenValue, blueValue, alphaValue);
}
Example of RGBA usage
div {
  background-color: rgba(255, 0, 0, 0.5); /* Red with 50% transparency */
}
div {
  background-color: rgba(255, 0, 0, 0.5); /* Red background with 50% transparency */
  color: black; /* Text remains fully opaque */
}
div {
  background-color: rgba(0, 0, 255, 0.5); /* Blue background with 50% transparency */
  color: white; /* Text is fully opaque */
}
.box {
  background-color: rgba(0, 0, 255, 0.7); /* Blue with 70% opacity */
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5); /* Shadow with 50% opacity */
}


hexa{
 background-color: #RRGGBBAA
}
#FF0000FF /* Fully opaque or 100% red */
#FF0000E6 /* Fully opaque or 90% red */
#FF0000CC /* Fully opaque or 80% red */
#FF0000B3 /* Fully opaque or 70% red */
#FF000099 /* Fully opaque or 60% red */
#FF000080 /* Fully opaque or 50% red */
#FF000066 /* Fully opaque or 40% red */
#FF00004D /* Fully opaque or 30% red */
#FF000033 /* Fully opaque or 20% red */
#FF00001A /* Fully opaque or 10% red */
#FF000040 /* Fully opaque or 25% red */
#FF0000BF /* Fully opaque or 75% red */
#FF000054 /* Fully opaque or 33% red */
#FF0000A8 /* Fully opaque or 66% red */


hsla{
  background-color: hsla(h, s%, l%, a)
}
/* Example of HSLA usage */
div {
  background-color: hsla(120, 100%, 50%, 0.3); /* Green with 30% transparency */
}
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
Opacity and Alpha Channel
/*-------------------------------------*/
1. Opacity is a property that sets the transparency level of an element. It affects the entire element, including its children.
Values range from 0 (fully transparent) to 1 (fully opaque).
div {
  opacity: 0.5; /* 50% transparent */
}

2. RGB with Alpha Channel (RGBA)
RGBA allows you to define colors using red, green, blue, and an alpha channel for transparency.
The alpha value ranges from 0 (fully transparent) to 1 (fully opaque).
div {
  background-color: rgba(255, 87, 51, 0.5); /* Semi-transparent red */
}

3. Hex with Alpha Channel (8-digit Hex Code)
The 8-digit hex code includes the standard 6 digits for RGB and 2 additional digits for the alpha channel.
The last two digits range from 00 (fully transparent) to FF (fully opaque).
div {
  background-color: #FF573380; /* 50% transparent red */
}

4. HSL with Alpha Channel (HSLA)
HSLA allows you to define colors using hue, saturation, lightness, and an alpha channel for transparency.
The alpha value ranges from 0 (fully transparent) to 1 (fully opaque).
div {
  background-color: hsla(0, 100%, 50%, 0.5); /* Semi-transparent red */
}

Summary Table
Color Model	      Syntax	             Alpha Value Range	              Example
Opacity	          opacity: value;	     0 (transparent) to 1 (opaque)	  opacity: 0.5;
RGBA	            rgba(r, g, b, a)	   0 to 1	                          background-color: rgba(255, 0, 0, 0.5);
Hex (8-digit)	    #RRGGBBAA	           00 (transparent) to FF (opaque)	background-color: #FF573380;
HSLA	            hsla(h, s%, l%, a)	 0 to 1	                          background-color: hsla(0, 100%, 50%, 0.5);

Conclusion
Using the alpha channel in these different color models allows for flexible control over transparency in web design, enhancing the visual effects of elements without affecting their layout or content. 
Choose the model that best fits your design needs and coding preferences.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS inherit value
/*-------------------------------------*/
In CSS, the inherit value is used to specify that a property should take the value of its parent element. 
This is part of the CSS inheritance model, where certain properties can be inherited from their parent elements by child elements.

What is Inheritance in CSS?
CSS inheritance allows you to define styles in a way that child elements can automatically adopt the styles set for their parent elements. 
This makes it easier to maintain and update styles across a web page.

Using inherit
When you explicitly set a property to inherit, you are telling the browser to use the value of that property from the parent element instead of using its own default value or any specified value.

Syntax:
element {
  property: inherit;
}

Example:
Here's an example that illustrates the use of inherit in CSS.
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        .parent {
            color: blue;
            font-size: 20px;
        }
        .child {
            color: inherit;  /* This will make the child's text color blue */
            font-size: inherit; /* This will make the child's font size 20px */
        }
    </style>
</head>
<body>
<div class="parent">
    This is the parent element.
    <p class="child">This is the child element, inheriting color and font size.</p>
</div>
</body>
</html>

Explanation of the Example:
The .parent class sets the text color to blue and the font size to 20 pixels.
The .child class uses color: inherit; and font-size: inherit;, meaning the child paragraph will inherit the color and font size from the parent div.
As a result, the text in the child paragraph will be blue and 20 pixels in size.

Properties That Can Be Inherited
Not all CSS properties are inherited. Commonly inherited properties include:

color
font-family
font-size
font-style
line-height
text-align
visibility
list-style

Common Use Cases for inherit:
1. Consistent Styling: When you want to maintain consistent styles throughout your document, using inherit helps to avoid duplication.
2. Overriding Styles: If an element has a default value or style set, using inherit allows you to override that with the parent’s value.
3. Theming: When implementing themes (like dark or light mode), setting properties to inherit ensures that child elements automatically follow the parent’s theme.

CSS Inheritance Hierarchy
The inheritance hierarchy starts at the <html> element at the top and flows down through parent elements to their children. 
This means that child elements can inherit styles from multiple levels of parent elements.

Conclusion
Using inherit in CSS is a powerful way to manage styles efficiently, ensuring that child elements can adopt styles from their parent elements. 
This leads to more maintainable and consistent designs throughout a web page or application.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS background-image property
/*-------------------------------------*/
The background-image property allows you to set a background image for an element, such as a div, body, or other block elements. 
You can also customize how the image is displayed using several related properties.

Basic Usage of background-image
element {
      background-image: url('image-url.jpg');
        }
body {
      background-image: url('background.jpg');
      }
This sets background.jpg as the background image for the <body> element.
  

Additional Properties for Background Images

1. background-repeat Controls whether the image repeats (tiles) or not.
repeat (default): The image repeats both horizontally and vertically.
no-repeat: The image does not repeat.
repeat-x: The image repeats only horizontally.
repeat-y: The image repeats only vertically.           
div {
    background-image: url('background.jpg');
    background-repeat: no-repeat;
    }

2. background-size Specifies the size of the background image.
auto: Default. The background image keeps its original size.
cover: Scales the image to cover the entire container, maintaining the aspect ratio.
contain: Scales the image to fit inside the container, maintaining the aspect ratio.
Specific dimensions (e.g., 100px 200px or percentages).
div {
    background-image: url('background.jpg');
    background-size: cover; /* Ensures the image covers the element */
    }

3. background-position Specifies the starting position of the background image. 
You can use keywords (top, center, bottom, left, right), pixel values, or percentages.
div {
    background-image: url('background.jpg');
    background-position: center center; /* Center the image in the div */
    }  

You can also use percentages for fine-tuned positioning:         
background-position: 50% 50%; /* Center */

4. background-attachment Determines whether the background image scrolls with the rest of the page or remains fixed.
scroll (default): The background image moves when scrolling.
fixed: The background image is fixed in place when scrolling.
local: The background scrolls with the element's content (for elements with scrollable content).*/
div {
    background-image: url('background.jpg');
    background-attachment: fixed;
    }

5. background-color Specifies a background color to be used as a fallback if the image doesn’t load, or as a base behind transparent areas of the image.
div {
    background-image: url('background.jpg');
    background-color: lightgray; /* Fallback color */
    }

6. background-clip Determines how far the background should extend within the element's box model (border, padding, or content).
border-box: The background extends behind the border.
padding-box: The background is painted up to the padding, but not under the border.
content-box: The background is only within the content area.
div {
    background-image: url('background.jpg');
    background-clip: content-box;
    }
    
7. background-origin Specifies the positioning area for the background image (similar to background-clip).
border-box: The image starts from the border.
padding-box: The image starts from the padding.
content-box: The image starts from the content area.
div {
    background-image: url('background.jpg');
    background-origin: padding-box;
    }

Shorthand for Background Properties
In CSS, the background property is a shorthand property used to set multiple background-related properties of an element in one declaration. You can use it to define color, image, position, size, repeat, and other background-related styles all at once.
You can combine multiple background properties into a single background shorthand property:
element {
  background: [color] [image] [position] / [size] [repeat] [attachment] [origin] [clip];
}
Same as:
div {
  background-color: #f0f0f0;
  background-image: url('image.jpg');
  background-repeat: no-repeat;
  background-position: center;
  background-size: cover;
  background-attachment: fixed;
  background-origin: border-box;
  background-clip: padding-box;
}

Example 1: When using both position and size, use the position / size syntax.
div {
  background: #f0f0f0 url('image.jpg') no-repeat center / cover fixed border-box;
}

Example 2:
element {
        background: url('background.jpg') no-repeat center/cover fixed lightgray;
        }
This shorthand combines:             
background-image: url('background.jpg')
background-repeat: no-repeat
background-position: center
background-size: cover
background-attachment: fixed
background-color: lightgray

Multiple Background Images
You can apply multiple background images to a single element by separating them with commas. Each background image can have its own set of properties.
div {
     background-image: url('image1.png'), url('image2.png');
     background-position: left top, right bottom;
     background-repeat: no-repeat, no-repeat;
    }
In this case, image1.png is positioned in the top-left corner, and image2.png is positioned in the bottom-right.
                  
Example: Full Page Background Image
body {
background-image: url('background.jpg');
background-size: cover;
background-position: center;
background-repeat: no-repeat;
background-attachment: fixed;
     }
This example ensures the background image covers the entire screen, remains centered, doesn't repeat, and stays fixed when scrolling.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS border property
/*-------------------------------------*/
The border property in CSS is used to define the border around an HTML element. 
It allows you to specify the width, style, and color of the border. 
You can use shorthand or individual properties to customize the appearance of the border.

Border Shorthand Syntax:
element {
  border: [border-width] [border-style] [border-color];
}
border-width: The thickness of the border (e.g., 2px, thin, medium, thick).
border-style: The style of the border (e.g., solid, dashed, dotted, double, none, etc.).
border-color: The color of the border (e.g., red, #FF5733, rgb(255, 87, 51)).  If no color is set, black is used by default.

Example of Shorthand:
div {
  border: 2px solid #FF5733; /* 2px wide, solid, orange border */
}

Border Property Breakdown:
You can also define each part of the border separately using individual properties:

border-width:
Defines the thickness of the border.
div {
  border-width: 3px;
}

border-style:
Defines the style of the border. Common styles include:
none: No border.
solid: A solid, continuous line.
dashed: A dashed line.
dotted: A dotted line.
double: Two solid lines.
groove: A carved, 3D effect.
ridge: A raised, 3D effect.
div {
  border-style: dashed;
}

border-color:
Defines the color of the border.
div {
  border-color: green;
}

Example of Individual Border Properties:
div {
  border-width: 5px;
  border-style: dotted;
  border-color: blue;
}

Border on Specific Sides:
You can apply borders to specific sides (top, right, bottom, left) of an element using these properties:
border-top
border-right
border-bottom
border-left
div {
  border-top: 4px solid red;
  border-bottom: 2px dashed green;
}

Example with Specific Side Borders:
div {
  border-left: 3px solid black;
  border-right: 5px dotted blue;
}

Rounded Borders:
To create rounded corners for borders, use the border-radius property. Example:
div {
  border: 2px solid blue;
  border-radius: 10px; /* Creates rounded corners */
}

Complete Example:
div {
  border: 2px solid #FF5733; /* Orange border */
  border-radius: 10px; /* Rounded corners */
  background-color: lightgray; /* Light gray background */
  padding: 20px; /* Padding inside the border */
}
This will apply a 2px solid orange border with rounded corners and light gray background to a div element.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS border-color Property
/*-------------------------------------*/
The border-color property in CSS is used to specify the color of an element's border. 
It allows you to control the appearance of the border by setting its color, enhancing the visual design of elements.

Key Features:
element {
  border-color: color; /* Sets the border color */
}

Color Values:
Named Colors: Common color names (e.g., red, blue).
Hexadecimal: Color codes (e.g., #ff0000 for red).
RGB/RGBA: Specify colors using RGB values (e.g., rgb(255, 0, 0)) or with transparency (e.g., rgba(255, 0, 0, 0.5)).
HSL/HSLA: Use Hue, Saturation, Lightness values (e.g., hsl(0, 100%, 50%)).

Example Usage:
div {
  border: 2px solid; /* Sets border width and style */
  border-color: blue; /* Sets the border color to blue */
}

Multiple Borders:
You can set different colors for each side of the border using:
element {
  border-color: red green blue yellow; /* top right bottom left */
}

Inheritance:
The border-color property is not inherited by child elements. 
Each element must have its border color defined if needed.

Key Points:
Visual Appeal: Borders enhance the design and can help define sections or elements within a layout.
Compatibility: The border-color property works in conjunction with border-width and border-style for full border customization.
The border-color property is essential for styling borders in web design, allowing for greater control over the aesthetics of elements.*/

This summary provides an overview of the border-color property, its features, usage, and examples.*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS box-shadow property
/*-------------------------------------*/
The box-shadow property lets you apply one or more shadows around an element. 
Here is basic syntax:
box-shadow: offsetX offsetY blurRadius spreadRadius color;

Here's how the offsetX and offsetY values work:
both offsetX and offsetY accept number values in px and other CSS units.
A positive offsetX value moves the shadow right and a negative value moves it left.
A positive offsetY value moves the shadow down and a negative value moves it up.
If you want a value of zero (0) for any or both offsetX and offsetY, you don't need to add a unit. Every browser understands that zero means no change.
The height and width of the shadow is determined by the height and width of the element it's applied to. 
You can also use an optional spreadRadius value to spread out the reach of the shadow. 

The box-shadow property in CSS is used to add shadow effects around an element's box. 
This property can create a sense of depth and dimension, enhancing the visual aesthetics of web elements.
Syntax:
box-shadow: [h-offset] [v-offset] [blur-radius] [spread-radius] [color];

Parameters:
h-offset: The horizontal offset of the shadow. Positive values move the shadow to the right, and negative values move it to the left.
v-offset: The vertical offset of the shadow. Positive values move the shadow down, and negative values move it up.
blur-radius (optional): The blur radius of the shadow. The higher the number, the more blurred the shadow will be. If omitted, the default is 0, which creates a sharp shadow.
spread-radius (optional): The size of the shadow. Positive values cause the shadow to expand and grow bigger, while negative values cause it to shrink. If omitted, the default is 0.
color: The color of the shadow. This can be specified in various formats, such as color names, hex values, or RGB/RGBA values.
div {
  box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.5); /* Right and down shadow with blur */
}
Breakdown of the Example:
5px (horizontal offset): The shadow is shifted 5 pixels to the right.
5px (vertical offset): The shadow is shifted 5 pixels down.
10px (blur radius): The shadow has a blur radius of 10 pixels.
rgba(0, 0, 0, 0.5) (color): The shadow is a semi-transparent black.

Complete Example with Multiple Shadows:
You can apply multiple shadows to an element by separating them with commas.
div {
  box-shadow: 
    2px 2px 5px rgba(0, 0, 0, 0.5), /* First shadow */
    -2px -2px 5px rgba(255, 0, 0, 0.5); /* Second shadow */
}

Inset Shadows:
To create an inset shadow (a shadow that appears inside the element), you can add the inset keyword before the offset values.
div {
  box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5); /* Inset shadow */
}

Example with Complete CSS:
Here’s a complete example to illustrate how to use the box-shadow property:
.card {
  width: 300px;
  height: 200px;
  background-color: white;
  border-radius: 10px; /* Rounded corners */
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3); /* Shadow effect */
  padding: 20px;
  margin: 20px;
}
Result:
This will create a card-like element with a white background, rounded corners, and a soft shadow effect beneath it, giving it a lifted appearance.

Important Notes:
The box-shadow property does not affect the layout of the element itself; it simply provides a visual effect.
The shadows can also be used creatively to achieve different design effects and are often used in UI design to emphasize buttons, cards, and other elements.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS background-color Property
/*-------------------------------------*/
The background-color property in CSS is used to set the background color of an element. 
This property enhances the visual appeal of elements and helps to distinguish sections of a webpage.

Key Features:
element {
  background-color: color; /* Sets the background color */
}

Color Values:
Named Colors: Common color names (e.g., red, green).
Hexadecimal: Color codes (e.g., #ff0000 for red).
RGB/RGBA: Specify colors using RGB values (e.g., rgb(255, 0, 0)) or with transparency (e.g., rgba(255, 0, 0, 0.5)).
HSL/HSLA: Use Hue, Saturation, Lightness values (e.g., hsl(0, 100%, 50%)).

Example Usage:
div {
  background-color: lightblue; /* Sets the background color to light blue */
}

Transparency:
The rgba and hsla values can be used to set a transparent background, allowing underlying elements to show through.

Inheritance:
The background-color property is not inherited by child elements. 
Each element must have its background color defined individually if desired.

Key Points:
Visual Impact: The background color enhances the design, improves readability, and can set the mood or theme of a webpage.
Layering Effects: Combined with other properties like background-image, background-size, and background-position, it allows for more complex visual effects.
The background-color property is fundamental in CSS for styling backgrounds, enabling designers to create visually appealing web layouts.

This summary provides an overview of the background-color property, its features, usage, and examples.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS overlflow property
/*-------------------------------------*/
The overflow CSS property controls what happens to content that overflows the bounds of an element's box. 
This is especially useful when content is too large to fit within the defined height or width of an element.

Values of overflow:
1. visible (default): Content is not clipped and will overflow the element's box.
overflow: visible;
2. hidden: Content that overflows the element's box will be clipped and not visible.
overflow: hidden;
3. scroll: Content that overflows the element’s box will be clipped, but scroll bars will be added (both vertical and horizontal if necessary).
overflow: scroll;
4. auto: Scroll bars will appear only if the content overflows the element’s box.
overflow: auto;
5. clip: Similar to hidden, but without adding scroll bars. It clips the content but doesn't provide any way to access the clipped content.
overflow: clip;

Example:
.box {
    width: 200px;
    height: 100px;
    overflow: auto;
}
This would allow a scroll bar to appear inside the .box if its content exceeds 200px by 100px.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/  
CSS vertical-align
/*-------------------------------------*/ 
Common vertical-align Values:
1. baseline (default):
Aligns the element’s baseline with the baseline of the parent.
Example: Inline images are by default aligned with the baseline of the surrounding text.
Example:
img {
  vertical-align: baseline;
}
2. top:
Aligns the top of the element with the top of the tallest element in the line.
Example:
img {
  vertical-align: top;
}
3. bottom:
Aligns the bottom of the element with the bottom of the lowest element in the line.
Example:
img {
  vertical-align: bottom;
}
4. middle:
Aligns the middle of the element with the middle of the parent element's line-height.
Example:
img {
  vertical-align: middle;
}
5. sub:
Aligns the element as subscript (below the baseline).
Example:
span {
  vertical-align: sub;
}
6. super:
Aligns the element as superscript (above the baseline).
Example:
span {
  vertical-align: super;
}
7. percentage values (e.g., vertical-align: 50%;):
This shifts the element up or down relative to its line box, with a value representing a percentage of the element’s line-height.

Example of vertical-align:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vertical Align Example</title>
  <style>
    img {
      vertical-align: middle;
    }
  </style>
</head>
<body>
  <p>
    This is text <img src="image.png" alt="image"> with an image vertically aligned to the middle of the text.
  </p>
</body>
</html>
In this example, the image is vertically aligned with the middle of the surrounding text using vertical-align: middle;.

Summary:
vertical-align is used to control the vertical positioning of inline or inline-block elements relative to their surrounding content.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS Horizontal Alignment
/*-------------------------------------*/
Horizontal Alignment for Block-Level Elements:
Block elements (e.g., <div>, <p>, <h1>) take up the full width of their container, so to horizontally align these elements, you usually center them by setting their margins.

Using margin: auto for block elements:
div {
  width: 50%;
  margin: 0 auto; /* Centers the div */
}

Horizontal Alignment for Inline or Inline-Block Elements:
For inline or inline-block elements (e.g., <span>, <img>, <a>), horizontal alignment can be controlled with the text-align property.

Using text-align for inline content within block elements:
div {
  text-align: center;
}

Horizontal Alignment for Flexbox:
When using Flexbox, you can horizontally align items with justify-content.

Example with Flexbox:
.container {
  display: flex;
  justify-content: center; /* Horizontally centers content */
}

Horizontal Alignment for Grid:
In CSS Grid, you can horizontally align items with justify-items or justify-content.

Example with Grid:
.grid-container {
  display: grid;
  justify-items: center; /* Centers grid items horizontally */
}

Summary:
There is no direct horizontal-align property, but horizontal alignment is achieved using properties like text-align, margin, justify-content (Flexbox), or justify-items (Grid) depending on the element's context and layout method.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS filter property
/*-------------------------------------*/
The filter property in CSS applies graphical effects such as blurring, color shifting, or brightness adjustments to elements, typically images, backgrounds, or any other content that can be rendered visually. 
It allows you to manipulate the appearance of an element by chaining multiple filter effects.

Common Filter Functions:
1. blur():
Applies a Gaussian blur to the element.
Syntax: blur(radius)
Example:
img {
  filter: blur(5px);
}
In this example, the image will have a blur with a 5-pixel radius.

2. brightness():
Adjusts the brightness of an element.
Syntax: brightness(percentage)
Example:
css
Copy code
img {
  filter: brightness(150%);
}
The image is 150% brighter than normal.

3. contrast():
Adjusts the contrast of the element.
Syntax: contrast(percentage)
Example:
css
Copy code
img {
  filter: contrast(200%);
}
The contrast of the image is doubled.

4. grayscale():
Converts the element’s colors to shades of gray.
Syntax: grayscale(percentage)
Example:
img {
  filter: grayscale(100%);
}
A 100% value will convert the image to fully grayscale.

5. invert():
Inverts the colors of the element (white becomes black, and vice versa).
Syntax: invert(percentage)
Example:
img {
  filter: invert(100%);
}
The image will have completely inverted colors.

6. opacity():
Adjusts the transparency of the element.
Syntax: opacity(percentage)
Example:
img {
  filter: opacity(50%);
}
The image will be 50% transparent.

7. saturate():
Adjusts the saturation of the element’s colors.
Syntax: saturate(percentage)
Example:
img {
  filter: saturate(200%);
}
The image will be twice as saturated.

8. sepia():
Applies a sepia tone to the element, giving it a warm, brownish color similar to old photographs.
Syntax: sepia(percentage)
Example:
img {
  filter: sepia(100%);
}
A 100% value fully applies the sepia effect.

9. hue-rotate():
Rotates the hue of the element's colors around the color wheel.
Syntax: hue-rotate(angle)
Example:
img {
  filter: hue-rotate(90deg);
}
This shifts the colors of the image by 90 degrees on the color wheel.
Combining Filters:
You can apply multiple filters to the same element by chaining them together.

Example of multiple filters:
img {
  filter: blur(5px) brightness(120%) contrast(150%);
}
The image will be blurred, brighter, and have increased contrast.

Default Value:
The default value for the filter property is none, meaning no filter effect is applied.
Browser Support:
The filter property is supported in all modern browsers. 
However, if you're supporting older versions of Internet Explorer or early versions of Edge, the filter property may not work as expected.

Example:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Filter Property Example</title>
  <style>
    img {
      filter: grayscale(100%) brightness(120%);
    }
  </style>
</head>
<body>

  <h1>CSS Filter Property Example</h1>
  <img src="image.jpg" alt="Sample Image">

</body>
</html>
In this example, the image will be displayed in grayscale with a slightly increased brightness.

Summary:
The filter property is a powerful tool for applying graphical effects to elements, especially images, in CSS.
It supports various functions like blur(), brightness(), contrast(), grayscale(), hue-rotate(), invert(), opacity(), saturate(), and sepia().
Multiple filters can be chained together to create complex effects.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
contrast() Function
/*-------------------------------------*/
Using the contrast() Function

The contrast() function adjusts the contrast of an element relative to its normal contrast level, where:
A value of 100% represents the original contrast.
A value below 100% decreases the contrast.
A value above 100% increases the contrast.

Syntax:
element {
  filter: contrast(value);
}
value: Can be a percentage (e.g., 150% for increased contrast) or a number (e.g., 1.5 for increased contrast). 
A value of 0% results in a completely flat, grayscale image with no contrast, while values above 100% increase the contrast.

Examples of Changing Contrast

Increasing Contrast:
img {
  filter: contrast(150%);
}
In this example, the contrast of the image is increased by 50%, making bright areas brighter and dark areas darker.

Decreasing Contrast:
img {
  filter: contrast(50%);
}
This example decreases the contrast by 50%, making the image appear more washed out or faded.

Example for a Full Element:
You can apply the contrast() function to any HTML element, not just images. For instance, adjusting contrast for a div with text and background:
div {
  filter: contrast(120%);
}
This will increase the contrast for everything inside the div, including the text and background color.

Combining Filters
You can also combine the contrast() function with other filters like brightness(), grayscale(), and blur() in the filter property to create more complex visual effects.
img {
  filter: contrast(150%) brightness(120%);
}
Browser Support
The filter property is well-supported in modern browsers (Chrome, Firefox, Edge, Safari), but you should check for compatibility in older versions if necessary.

Conclusion
The contrast() function within the filter property is an easy and powerful way to manipulate the contrast of images, backgrounds, or entire elements in CSS, allowing for creative visual effects or accessibility adjustments.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS border-radius property
/*-------------------------------------*/
The CSS border-radius property allows you to define the radius of the element's corners, either for all four corners or for specific ones, giving elements a softer, rounded appearance.

Syntax of border-radius:
element {
  border-radius: value;
}

Single Value (Uniform Radius for All Corners):
Example:
div {
  border-radius: 10px;
}
This will round all four corners of the div with a radius of 10 pixels.

Different Values for Each Corner:
You can also apply different values for each corner by specifying multiple values.

Order of Values (clockwise):
1. Top-left
2. Top-right
3. Bottom-right
4. Bottom-left

Example:
div {
  border-radius: 10px 20px 30px 40px;
}
This applies:
10px to the top-left corner,
20px to the top-right corner,
30px to the bottom-right corner,
40px to the bottom-left corner.

Elliptical (Different Horizontal and Vertical Radii):
You can create an elliptical corner shape by specifying two values, one for the horizontal radius and one for the vertical radius.

Example:
div {
  border-radius: 50px / 20px;
}
This applies a horizontal radius of 50 pixels and a vertical radius of 20 pixels, creating an elliptical curve.

Percentage Values:
You can also use percentages to create rounded corners relative to the element's size.

Example:
div {
  border-radius: 50%;
}
This will make the element perfectly circular if the width and height are equal.

Using border-radius for Specific Corners:
If you want to target specific corners, you can use the following properties:

1. border-top-left-radius
2. border-top-right-radius
3. border-bottom-right-radius
4. border-bottom-left-radius

Example:
div {
  border-top-left-radius: 20px;
  border-bottom-right-radius: 30px;
}
This rounds only the top-left and bottom-right corners.

Practical Example:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Border Radius Example</title>
  <style>
    div {
      width: 200px;
      height: 200px;
      background-color: lightblue;
      border-radius: 25px;
    }
  </style>
</head>
<body>

  <h1>CSS Border Radius Example</h1>
  <div>This div has rounded corners!</div>

</body>
</html>
Summary:
The border-radius property allows you to define rounded corners for elements.
You can specify one value for uniform rounding, multiple values for individual corners, or create elliptical shapes using two values.
It accepts both pixel (or other unit) and percentage values for flexibility.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS transform property
/*-------------------------------------*/
The transform property in CSS is used to apply 2D or 3D transformations to an element. 
It allows you to rotate, scale, skew, or translate (move) an element without affecting other elements in the document flow. 
The transformations are performed relative to the element's origin point.

Syntax:
element {
  transform: function(value);
}
You can chain multiple transformation functions by separating them with spaces.

Common Transform Functions:

1. translate(x, y):
Moves the element along the X and/or Y axes.
Syntax: translate(x, y) where x is the horizontal movement, and y is the vertical movement.
Example:
div {
  transform: translate(50px, 100px); /* Moves the div 50px right and 100px down */
}

2. rotate(angle):
Rotates the element around its origin point.
Syntax: rotate(angle) where the angle is specified in degrees (deg) or radians.
Example:
div {
  transform: rotate(45deg); /* Rotates the div by 45 degrees clockwise *//*can be rotated fractionally 0.1/0.3 ect*/
}
div {
  transform: rotate(-45deg); /* Rotates the div by 45 degrees counter or anti-clockwise *//*can be rotated fractionally -0.1/-0.3 ect*/
}

3. scale(x, y):
Scales the size of the element.
Syntax: scale(x, y) where x is the scaling factor for the width and y for the height.
If you only provide one value, it scales both axes equally (i.e., scale(x) is equivalent to scale(x, x)).
Example:
div {
  transform: scale(1.5, 2); /* Scales the div 1.5x horizontally and 2x vertically */
}

4. skew(x-angle, y-angle):
Skews the element along the X and/or Y axes.
Syntax: skew(x-angle, y-angle) where x-angle and y-angle are in degrees.
Example:
div {
  transform: skew(30deg, 10deg); /* Skews the div by 30 degrees on the X-axis and 10 degrees on the Y-axis */
}

5. matrix(a, b, c, d, e, f):
Applies a combination of transformations (scaling, rotation, translation, and skewing) using a matrix.
Syntax: matrix(a, b, c, d, e, f) is an advanced function that combines multiple transformations.
Example (a basic one):
div {
  transform: matrix(1, 0, 0, 1, 50, 100); /* Equivalent to translate(50px, 100px) */
}

2D Transformation Example:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Transform Property Example</title>
  <style>
    div {
      width: 100px;
      height: 100px;
      background-color: lightblue;
      transform: rotate(45deg) translate(50px, 50px) scale(1.2);
    }
  </style>
</head>
<body>
  <div>This div is transformed!</div>
</body>
</html>
In this example, the div is rotated 45 degrees, translated (moved) 50px on both the X and Y axes, and scaled 1.2 times its original size.
3D Transform Functions:

1. translate3d(x, y, z):
Moves the element in 3D space.
Example:
div {
  transform: translate3d(50px, 100px, 200px);
}

2. rotateX(angle):
Rotates the element around the X-axis.
Example:
div {
  transform: rotateX(45deg);
}

3. rotateY(angle):
Rotates the element around the Y-axis.
Example:
div {
  transform: rotateY(45deg);
}

4. rotateZ(angle) (similar to 2D rotation):
Rotates the element around the Z-axis.
Example:
div {
  transform: rotateZ(45deg);
}

5. perspective(n):
Sets a perspective view for 3D-transformed elements. The lower the value of n, the closer the viewpoint.
Example:
div {
  transform: perspective(500px) rotateY(45deg);
}

Transform Origin:
The origin of transformation can be changed using the transform-origin property. 
By default, transformations are applied relative to the center of the element (50% 50%).

Example:
div {
  transform-origin: top left;
  transform: rotate(45deg);
}

In the context of computer graphics, CSS, or animations, transform-origin defines the point around which an element's transformations (like scaling, rotating, or skewing) are applied. 
By default, this point is the center of the element, but you can change it to any other point using the transform-origin property.

Syntax:
transform-origin: x-axis y-axis z-axis;
x-axis: Specifies the horizontal position (e.g., left, center, right, or a percentage like 50%, or pixel values).
y-axis: Specifies the vertical position (e.g., top, center, bottom, or a percentage).
z-axis (optional): Specifies the depth (used mostly for 3D transformations, can be a pixel value like 0px).
Example:
div {
  transform: rotate(45deg);
  transform-origin: top left;
}
In this example, the element will rotate 45 degrees around its top-left corner instead of its center.

Practical uses:

Animation effects: Rotating or scaling an object around a corner or edge.
Perspective in 3D transforms: Setting the origin can affect how an element looks when applying 3D transformations like rotateX, rotateY, etc.

Chaining Multiple Transformations:
You can combine multiple transformation functions together by separating them with spaces.

Example:
div {
  transform: translate(50px, 100px) rotate(30deg) scale(1.2);
}

Transitions and Animations with Transform:
The transform property works very well with CSS transitions and animations, allowing you to create smooth and complex effects.

Example of transition with transform:
div {
  transition: transform 0.5s ease;
}

div:hover {
  transform: scale(1.5) rotate(45deg);
}

Summary:
The transform property is a powerful tool that allows you to apply 2D and 3D transformations like translate, rotate, scale, and skew.
You can chain multiple transformation functions together and apply them in combination for more complex effects.
The transformations happen without affecting the document flow, so elements can be moved or changed visually without disturbing other elements.














/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS box-sizing property
/*-------------------------------------*/
The box-sizing property in CSS defines how the width and height of an element are calculated, including or excluding padding and borders. 
It controls the box model behavior for an element, affecting how the size of the element is determined when padding, borders, and content are combined.

The box-sizing property is used to set this behavior. 
By default, the content-box model is used. 
With this model, when an element has a specific width, that width is calculated based only on the element's content. 
Padding and border values get added to the total width, so the element grows to accommodate these values.

The border-box sizing model does the opposite of content-box. 
The total width of the element, including padding and border, will be the explicit width set. 
The content of the element will shrink to make room for the padding and border.

Values of box-sizing:

1. content-box (default behavior):
   The width and height of the element only include the content. 
   Padding and borders are added to the size of the element.
   This is the default behavior in CSS.

Example:
div {
  width: 200px;
  padding: 10px;
  border: 5px solid black;
  box-sizing: content-box; /* Default */
}
The element's total width will be 200px (content width) + 10px (left padding) + 10px (right padding) + 5px (left border) + 5px (right border) = 230px total width.

2. border-box:
   The width and height include the padding and borders. 
   In this case, the total size of the element is constrained to the declared width and height.
   Padding and border are inside the specified width and height.

Example:
div {
  width: 200px;
  padding: 10px;
  border: 5px solid black;
  box-sizing: border-box;
}
The element’s total width will remain 200px, and the padding and borders will be adjusted inside this width, so the content area will shrink to accommodate them.

Differences Between content-box and border-box:
Property	    content-box (Default)	                                                            border-box
Width/Height	Only the content width/height is defined. Padding and borders are added to this.	Width/height includes the padding and border, so the content shrinks to fit inside.
Padding	      Adds to the element's size	                                                      Included within the declared width/height
Borders	      Adds to the element's size	                                                      Included within the declared width/height

Practical Example:
This example shows the difference between content-box and border-box:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    .content-box {
      width: 200px;
      padding: 20px;
      border: 5px solid red;
      box-sizing: content-box; /* Default */
      background-color: lightblue;
      margin-bottom: 20px;
    }
    .border-box {
      width: 200px;
      padding: 20px;
      border: 5px solid green;
      box-sizing: border-box;
      background-color: lightgreen;
    }
  </style>
  <title>Box Sizing Example</title>
</head>
<body>
  <div class="content-box">Content Box</div>
  <div class="border-box">Border Box</div>
</body>
</html>
The first div (with content-box) will have a larger total width because the padding and borders are added to the width.
The second div (with border-box) will have a total width of exactly 200px, with padding and borders adjusted inside the box.

Why Use border-box?
Simplifies layout calculations: Using border-box ensures that the size of an element stays consistent regardless of padding and borders, which simplifies responsive design and layout adjustments.
Common for modern layouts: Many developers set box-sizing: border-box; as the global default to avoid unexpected layout shifts when adding padding or borders.

Global Reset for Box-Sizing:
To apply box-sizing: border-box to all elements on a page, a common practice is to use this CSS reset:
*,
*::before,
*::after {
  box-sizing: border-box;
}
This ensures that every element on the page calculates its width and height using the border-box model.

Summary:
box-sizing: content-box; (default): The width/height only includes the content. Padding and borders are added outside the declared size.
box-sizing: border-box;: The width/height includes content, padding, and borders. This model simplifies layout calculations.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS object-fit property
/*-------------------------------------*/
The object-fit property in CSS is used to specify how an <img> or <video> element should be resized to fit its container. 
This property is particularly useful for controlling the appearance of media elements when their aspect ratio does not match that of their container.

Syntax:
img {
  object-fit: value;
}

Values of object-fit:
1. fill (default):
The content is resized to fill the container completely. 
This may distort the content if the aspect ratio of the content does not match the aspect ratio of the container.
Example:
img {
  object-fit: fill;
}
2. contain:
The content is resized to fit within the container while maintaining its aspect ratio. 
This means the entire content will be visible, but there may be empty space in the container if the aspect ratios do not match.
Example:
img {
  object-fit: contain;
}
3. cover:
The content is resized to completely cover the container while maintaining its aspect ratio. 
This means that parts of the content may be clipped if the aspect ratios do not match, but there will be no empty space in the container.
Example:
img {
  object-fit: cover;
}
4. none:
The content is not resized at all. 
It retains its original size, and any overflow will be visible outside the container.
Example:
img {
  object-fit: none;
}
5. scale-down:
The content is sized as none or contain, whichever is smaller. 
This means it will be displayed at its original size unless it is larger than the container, in which case it will be scaled down to fit.
Example:
img {
  object-fit: scale-down;
}

Example Usage:
Here is a practical example showing how the object-fit property works:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Object Fit Example</title>
  <style>
    .container {
      width: 300px;
      height: 200px;
      border: 2px solid #000;
      margin: 20px;
      overflow: hidden; /* Prevent overflow of content */
    }
    .fill {
      object-fit: fill;
    }
    .contain {
      object-fit: contain;
    }
    .cover {
      object-fit: cover;
    }
    .none {
      object-fit: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <img class="fill" src="https://via.placeholder.com/400x300" alt="Fill">
  </div>
  <div class="container">
    <img class="contain" src="https://via.placeholder.com/400x300" alt="Contain">
  </div>
  <div class="container">
    <img class="cover" src="https://via.placeholder.com/400x300" alt="Cover">
  </div>
  <div class="container">
    <img class="none" src="https://via.placeholder.com/400x300" alt="None">
  </div>
</body>
</html>
Explanation of the Example:
The .container class sets the dimensions and styling for the containers holding the images.
The four images demonstrate the different values of object-fit:
1. Fill: The image stretches to fill the entire container, which may distort its appearance.
2. Contain: The image maintains its aspect ratio, and fits within the container, possibly leaving empty space.
3. Cover: The image fills the container, maintaining its aspect ratio, but may be clipped.
4. None: The image retains its original size, and any part that exceeds the container's dimensions will overflow.

Browser Support:
The object-fit property is well-supported in modern browsers, but it's a good practice to check compatibility for older browsers if necessary.

Use Cases:
Responsive Design: object-fit is especially useful in responsive design scenarios where images and videos need to adapt to different screen sizes and orientations without distortion.
Image Galleries: In galleries or portfolios, you can maintain a consistent layout and appearance without having to manually crop images.

Summary:
The object-fit property is a powerful tool for controlling the sizing behavior of images and videos in a container.
It offers flexibility with various values like fill, contain, cover, none, and scale-down, allowing developers to easily manage visual layouts and maintain aspect ratios as needed.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS properties aspect-ratio and object-fit
/*-------------------------------------*/
The CSS properties aspect-ratio and object-fit are both used for controlling how media elements like images, videos, or containers behave within a layout. 
While both influence how content is displayed within a given space, they serve different purposes and have distinct behaviors.

1. aspect-ratio Property:
/*-------------------------------------*/
The aspect-ratio property in CSS allows you to define the width-to-height ratio of an element. 
This ensures that the element maintains a consistent proportion regardless of its size, based on the defined aspect ratio.

Syntax:
.element {
  aspect-ratio: width / height;
}

Examples:
.element {
  aspect-ratio: 16 / 9;  /* A widescreen ratio, like for videos or images */
}
Aspect Ratio Explained: If you set aspect-ratio: 16/9;, this means that for every 16 units of width, the element will have 9 units of height. 
This maintains the same proportional relationship regardless of how much the container grows or shrinks.
Behavior: When using aspect-ratio, the element (such as an image or div) will scale dynamically, maintaining its proportions, even if its width or height is altered. 
The content inside adjusts to fit this proportion.

Use Cases for aspect-ratio:
Video Containers: Ensuring a video or image keeps a consistent size (like 16:9 for widescreen).
Responsive Image Grids: Ensuring items in a grid maintain a uniform ratio, regardless of screen size.
Example of Use:
.video-container {
  aspect-ratio: 16 / 9;
  width: 100%;
  background: url('video-thumbnail.jpg') no-repeat center;
  background-size: cover;
}

2. object-fit Property:
The object-fit property is used to control how the content of an element, such as an image or video, fits inside its container. 
This property works primarily with replaced elements like <img>, <video>, or <iframe>. Unlike aspect-ratio, it doesn’t affect the container size but adjusts how the content inside the container is handled.

Syntax:
img {
  object-fit: value;
}

Common object-fit Values:
1. fill (default): The content stretches to fit the container, possibly distorting the aspect ratio.
2. contain: The content is scaled to fit within the container while preserving its aspect ratio. 
   If the container’s aspect ratio is different from the content’s, letterboxing (empty space) may appear.
3. cover: The content is scaled to completely fill the container, preserving its aspect ratio. 
   Parts of the content might be cropped if the container’s aspect ratio is different.
4. none: The content is displayed at its original size, and it’s not resized to fit the container.
5. scale-down: The content is scaled down to the smallest size possible (using either none or contain), but it will not scale up to be larger than the original content.

Examples:
img {
  object-fit: cover;  /* The image will cover the container, possibly cropping */
}
Behavior: The object-fit property doesn’t change the size of the element itself. Instead, it modifies how the image, video, or other media content behaves within the element. 
For example, with object-fit: cover, the image will fill the container, maintaining its aspect ratio, but the edges might be cropped.
Use Cases for object-fit:

Image Galleries: Ensure that images always fill their containers, while either cropping or showing the entire image based on the desired effect.
Background Images: When images need to cover an area without distorting or stretching, like in hero sections.
Videos in Containers: Ensuring video content scales appropriately within a container.

Example of Use:
.image-container img {
  width: 100%;
  height: 300px;
  object-fit: cover;  /* Ensures the image covers the full container without distortion */
}

Key Differences:
Feature	                 aspect-ratio	                                                                object-fit
What it controls	       The proportion (width-to-height ratio) of the element itself (container).	  How the content (image, video) fits inside its container.
Affects container size?	 Yes, it defines the shape of the container itself.	                          No, it only controls how the content inside behaves.
Use case	               Ensuring elements maintain a consistent ratio (e.g., 16:9 video container).	Adjusting the fit of images or videos inside containers without changing container size.
Works with	             All elements (divs, containers, etc.).	                                      Replaced elements (images, videos, iframes).
Common values	           Ratios like 16/9, 4/3, 1/1.	                                                fill, contain, cover, none, scale-down.
Example	                 aspect-ratio: 16 / 9;	                                                      object-fit: cover;

Which to Use and When?
1. Use aspect-ratio when you want the container itself to maintain a certain proportion regardless of content.
   Example: A video container where you want to preserve the 16:9 aspect ratio.
2. Use object-fit when you want to control how media content (like an image or video) fits within a fixed container.
   Example: Ensuring an image fills its container while keeping its original proportions without stretching.

Combining aspect-ratio and object-fit:
These two properties can be used together for precise control of both container size and content fit. 
For example, you can use aspect-ratio to maintain a specific container shape and object-fit to control how the media inside behaves.

Example:
.image-container {
  aspect-ratio: 16 / 9;
  width: 100%;
}

.image-container img {
  object-fit: cover;
  width: 100%;
  height: 100%;
}
The container maintains a 16:9 aspect ratio.
The image inside will cover the container, possibly cropping to maintain its proportions.
Conclusion:
aspect-ratio defines the shape and proportion of the container.
object-fit controls how the content (media) behaves inside a container, without changing the container’s size.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
Center an Image
/*-------------------------------------*/
To center an image in CSS, you can achieve this depending on whether you're centering the image horizontally, vertically, or both. Here are the common techniques for centering images:

1. Centering Horizontally with text-align: center;
If the image is inside a block-level container (like a div), you can use the text-align property on the parent element:
<div style="text-align: center;">
  <img src="image.jpg" alt="Centered Image">
</div>
This method works because images are inline elements, so text-align: center; centers them within the block-level parent.

2. Centering Horizontally with margin: auto;
If the image is a block-level element (or you make it block-level), you can use margin: auto to center it horizontally.
<img src="image.jpg" alt="Centered Image" style="display: block; margin: 0 auto;">
display: block; makes the image a block-level element.
margin: 0 auto; sets the left and right margins to automatically distribute space evenly, centering the image.

3. Centering Vertically with Flexbox
You can center an image both vertically and horizontally using Flexbox. Apply Flexbox styles to the container of the image:
<div style="display: flex; justify-content: center; align-items: center; height: 100vh;">
  <img src="image.jpg" alt="Centered Image">
</div>
display: flex; makes the container a flexbox.
justify-content: center; centers the image horizontally.
align-items: center; centers the image vertically.
height: 100vh; ensures the container takes up the full height of the viewport.

4. Centering Horizontally and Vertically with position
You can use the position property with transform to center the image both horizontally and vertically:
<div style="position: relative; height: 100vh;">
  <img src="image.jpg" alt="Centered Image" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
</div>
position: absolute; positions the image relative to its nearest positioned ancestor.
top: 50%; and left: 50%; position the image at 50% of the container’s height and width.
transform: translate(-50%, -50%); adjusts the image so that its center aligns with the 50% position of its container.

5. Centering in Grid Layout
CSS Grid can also be used to center images:
<div style="display: grid; place-items: center; height: 100vh;">
  <img src="image.jpg" alt="Centered Image">
</div>
display: grid; creates a grid layout.
place-items: center; centers the image both vertically and horizontally.
height: 100vh; ensures the container takes up the full height of the viewport.

Summary
Use text-align: center; for inline images inside block elements.
Use margin: auto; to horizontally center block images.
Use Flexbox or Grid to center images both horizontally and vertically.
Use position: absolute; with transform for fine-grained centering in specific cases.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
The place-items property in CSS is a shorthand property used in CSS Grid and CSS Flexbox layouts. It allows you to set both the align-items and justify-items properties in one line, controlling the alignment of items within the grid or flex container.

Syntax:
place-items: align-items justify-items;
align-items: Aligns items along the block axis (vertically in a horizontal writing mode).
justify-items: Aligns items along the inline axis (horizontally in a horizontal writing mode).

Possible Values:
Both align-items and justify-items can take these values:
start: Align items at the start of the container.
end: Align items at the end of the container.
center: Center items within the container.
stretch: Stretch items to fill the container (this is the default for align-items).

Example:
.container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  height: 300px;
  place-items: center start;
}
In this example:
The items will be centered along the vertical axis (align-items: center).
They will be aligned at the start of the horizontal axis (justify-items: start).

Shorthand Behavior:
If you only specify one value, that value applies to both axes. For example:
place-items: center;
This is equivalent to:
align-items: center;
justify-items: center;

Usage with Grid:
The place-items property is often used with CSS Grid to quickly align grid items both horizontally and vertically.

Usage with Flexbox:
Though place-items can technically be used with Flexbox, Flexbox aligns items using align-items and justify-content, and the shorthand place-items doesn't control justify-content. Therefore, it's more commonly associated with CSS Grid layouts.

Example in CSS Grid:
.grid-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: 200px 200px;
  place-items: center;
}
This centers the grid items both vertically and horizontally within each grid cell.

In summary, place-items is a handy shorthand for aligning items inside grid containers, saving you time by combining the properties into one concise declaration.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS Grid and Flexbox
/*-------------------------------------*/
CSS Grid and Flexbox are both powerful layout models in CSS that allow you to build complex, responsive layouts. 
However, they have distinct use cases, behaviors, and strengths. Let's break down the differences, strengths, and when to use each.

1. CSS Grid
CSS Grid is a two-dimensional layout system designed to handle both rows and columns simultaneously. 
It is ideal for creating layouts where you want precise control over both the horizontal and vertical placement of elements.

Key Features of CSS Grid:
1.1 Two-dimensional: CSS Grid works in both rows and columns, allowing you to design more complex layouts.
1.2 Explicit grid structure: You define a grid using grid-template-rows, grid-template-columns, and grid-template-areas, and place elements accordingly.
1.3 Grid lines: Items can be positioned using grid lines, giving fine control over layout placement.
1.4 Gaps: You can define gaps between rows and columns with grid-gap, row-gap, and column-gap.
1.5 Overlapping elements: CSS Grid allows elements to overlap by positioning them in the same grid cell or area.
1.6 Template areas: You can name grid areas and then position items by referring to those names.

Syntax Example:
.container {
  display: grid;
  grid-template-columns: 200px 1fr 200px; /* Defines three columns */
  grid-template-rows: auto 300px;         /* Defines two rows */
  gap: 10px;                              /* Gap between rows and columns */
}
.item1 {
  grid-column: 1 / 3;  /* Item spans the first two columns */
  grid-row: 1;         /* Positioned in the first row */
}
.item2 {
  grid-column: 2 / 4;  /* Item spans the second and third columns */
  grid-row: 2;         /* Positioned in the second row */
}
When to Use CSS Grid:
When you need to design layouts with both rows and columns.
When you have complex 2D layouts with precise positioning requirements.
When the layout involves overlapping elements (like layering images and text).

2. Flexbox
CSS Flexbox is a one-dimensional layout system, focusing either on a row (horizontal axis) or a column (vertical axis). 
Flexbox excels at distributing space within a container and aligning items dynamically.

Key Features of Flexbox:
2.1 One-dimensional: Flexbox operates along a single axis (either row or column).
2.2 Flexibility: Flexbox is designed to distribute space dynamically based on the size of the container, making it ideal for responsive design.
2.3 Alignment: Flexbox offers powerful alignment features like justify-content, align-items, and align-self to align items along the main and cross axes.
2.4 Order control: You can reorder elements within the container without changing the source HTML, using the order property.
2.5 Flexible sizing: Flexbox allows items to grow (flex-grow) or shrink (flex-shrink) to fill available space, and define relative sizing with flex-basis.

Syntax Example:
.container {
  display: flex;
  justify-content: space-between;  /* Distributes items evenly */
  align-items: center;             /* Aligns items vertically in the center */
}
.item1 {
  flex: 1;   /* Item takes up all available space */
}
.item2 {
  flex: 2;   /* Item takes twice the space of item1 */
}
When to Use Flexbox:

When you need to arrange items in a single direction (either row or column).
For responsive design that needs flexible and dynamic sizing and alignment of elements.
When the layout involves simple alignment or distribution of elements, like buttons in a navigation bar or items in a card layout.

Key Differences Between Grid and Flexbox:
Feature	CSS                  Grid	                                                                                        Flexbox
Layout Type	                 Two-dimensional (rows and columns).	                                                        One-dimensional (row or column).
Main Use Case	               Complex layouts where you need precise control over both horizontal and vertical placement.	Simple layouts where you arrange items in one direction and need flexibility in sizing.
Primary Axis	               Works with both axes (horizontal and vertical).	                                            Focuses on one axis (main axis is row or column).
Flexibility	                 Less dynamic in terms of item resizing; more for precise grid placement.	                    Highly flexible and responsive, designed to adapt to container size changes.
Control Over Alignment	     Requires grid line placement for alignment.	                                                Offers powerful alignment tools like justify-content and align-items.
Gaps Between Elements	       Supports row and column gaps (grid-gap, row-gap, column-gap).	                              Supports gap, but is primarily about distributing space.
Overlapping Elements	       Can easily overlap elements in the same grid area or cell.	                                  Overlapping is not a core feature; more for distributing items along a single axis.
Content Reordering	         Grid elements can be placed anywhere on the grid without needing to reorder HTML.	          Flexbox allows reordering using the order property.
Browser Support	             Widely supported but was introduced later than Flexbox.	                                    Fully supported in all modern browsers.

When to Use CSS Grid vs. Flexbox

1. Use CSS Grid When:
1.1 You need to build complex, two-dimensional layouts that require control over both rows and columns.
1.2 You need to create a grid-based layout with rows and columns that adapt depending on the content.
1.3 You want to position items precisely within a grid, with full control over where each element appears.
1.4 You want to create overlapping layers or more complex designs where elements need to share the same space (e.g., layering images with text).

2. Use Flexbox When:
2.1 You have a one-dimensional layout that works in either a row or a column.
2.2 You need a flexible, responsive layout that adapts well to different screen sizes and content lengths.
2.3 You need to easily align and distribute items within a container, especially when you don’t need control over rows and columns.
2.4 You’re building components like navbars, cards, or small sections of a page that require alignment and flexible distribution of space.

Combining CSS Grid and Flexbox
In many cases, you don’t have to choose just one. You can use CSS Grid for the overall page layout (for example, dividing the page into header, content, and footer areas) and Flexbox inside individual components (for example, to align buttons or arrange content within a card).

Example of Using Both:
/* Grid for overall layout */
.page-container {
  display: grid;
  grid-template-columns: 200px 1fr 200px;
  grid-template-rows: auto 1fr auto;
}
/* Flexbox for aligning items within the header */
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
Here, Grid is used for the page layout, dividing the page into columns and rows.
Flexbox is used within the header for easy alignment of navigation links or buttons.

Conclusion:
CSS Grid excels at two-dimensional layouts, allowing precise control over both rows and columns.
Flexbox is ideal for one-dimensional layouts and provides flexibility in distributing and aligning items along a single axis.
You can use both together to create sophisticated, responsive layouts that are easy to manage and scale.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS gap property
/*-------------------------------------*/
The gap property in CSS is used to define the space between items in a grid or flex container. 
It is a shorthand for the row-gap and column-gap properties and allows for a more straightforward way to control spacing in layouts without needing to set margins on the individual items.
The gap CSS shorthand property sets the gaps, also known as gutters, between rows and columns. 
The gap property and its row-gap and column-gap sub-properties provide this functionality for flex, grid, and multi-column layout. 
You apply the property to the container element.
Syntax:
.container {
  display: flex; /* or display: grid; */
  gap: <row-gap> <column-gap>; /* or just gap: <size>; for uniform spacing */
}

Values of gap:

1. Single Value:
When a single value is specified, it applies the same gap to both rows and columns.
Example:
.container {
  display: grid;
  gap: 20px; /* 20px gap between both rows and columns */
}

2. Two Values:
The first value sets the gap between rows (row-gap), and the second value sets the gap between columns (column-gap).
Example:
.container {
  display: grid;
  gap: 10px 20px; /* 10px gap between rows and 20px gap between columns */
}

Supported Units:
The gap property can accept values in various CSS length units, including:
1. Pixels (px)
2. Ems (em)
3. Rems (rem)
4. Percentages (%)
5. Viewport units (vw, vh)

Example Usage with Flexbox:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gap Property Example</title>
  <style>
    .flex-container {
      display: flex;
      gap: 20px; /* Space between flex items */
    }
    .flex-item {
      background-color: lightblue;
      padding: 20px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="flex-container">
    <div class="flex-item">Item 1</div>
    <div class="flex-item">Item 2</div>
    <div class="flex-item">Item 3</div>
  </div>
</body>
</html>

Example Usage with Grid:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gap Property Example</title>
  <style>
    .grid-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px; /* Space between grid items */
    }
    .grid-item {
      background-color: lightcoral;
      padding: 20px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="grid-container">
    <div class="grid-item">1</div>
    <div class="grid-item">2</div>
    <div class="grid-item">3</div>
    <div class="grid-item">4</div>
    <div class="grid-item">5</div>
    <div class="grid-item">6</div>
  </div>
</body>
</html>

Key Points:
Flexbox and Grid: The gap property can be used with both flex and grid layouts.
No Margins Needed: The gap property eliminates the need to apply margins to individual items, making the code cleaner and more maintainable.
Browser Support: The gap property is supported in modern browsers, but be cautious about using it with flexbox in older versions of Internet Explorer.

Conclusion:
The gap property is a valuable addition to CSS, providing a simple way to manage spacing between elements in flex and grid layouts. 
By using gap, you can create visually appealing layouts without the complexity of managing individual margins, leading to cleaner and more maintainable CSS.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS justify-content and align-content properties
/*-------------------------------------*/
The justify-content and align-content are both CSS properties used in Flexbox and Grid layouts to control the alignment of items within a container. 
However, they serve different purposes and operate along different axes. 
Here’s a detailed comparison of the two:

1. justify-content
Purpose: Controls the alignment of flex or grid items along the main axis of the container.
Main Axis:
In a flex container with flex-direction: row, the main axis is horizontal (left to right).
In a flex container with flex-direction: column, the main axis is vertical (top to bottom).

Common Values:
1.1 flex-start: Aligns items to the start of the main axis.
1.2 flex-end: Aligns items to the end of the main axis.
1.3 center: Centers items along the main axis.
1.4 space-between: Distributes items evenly, with the first item at the start and the last item at the end.
1.5 space-around: Distributes items evenly, with space around each item.
1.6 space-evenly: Distributes items with equal space between them.

Example of justify-content:
.container {
  display: flex;
  justify-content: space-between; /* Align items with space between them */
}

2. align-content
Purpose: Controls the alignment of flex or grid items along the cross axis of the container. 
It is relevant only when there is extra space in the container and the items are wrapped into multiple lines.
Cross Axis:
In a flex container with flex-direction: row, the cross axis is vertical (top to bottom).
In a flex container with flex-direction: column, the cross axis is horizontal (left to right).

Common Values:
2.1 flex-start: Aligns lines to the start of the cross axis.
2.2 flex-end: Aligns lines to the end of the cross axis.
2.3 center: Centers lines along the cross axis.
2.4 space-between: Distributes lines evenly, with the first line at the start and the last line at the end.
2.5 space-around: Distributes lines evenly, with space around each line.
2.6 stretch: Stretches the lines to fill the container (default value).

Example of align-content:
.container {
  display: flex;
  flex-wrap: wrap; /* Allows items to wrap onto multiple lines */
  align-content: center; /* Aligns wrapped lines in the center of the container */
}

Key Differences:
Feature	      justify-content	                                       align-content
Axis	        Main axis (horizontal for rows, vertical for columns)	 Cross axis (vertical for rows, horizontal for columns)
When to Use	  When aligning items along the main axis	               When there is extra space in the container and items wrap to multiple lines
Effect	      Adjusts spacing between items in a single line	       Adjusts spacing between lines of items

Visual Example:
Here’s a visual representation to clarify how both properties work:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>justify-content vs align-content</title>
  <style>
    .container {
      display: flex;
      flex-wrap: wrap;
      height: 300px; /* Set height for demonstration */
      border: 1px solid #ccc;
      margin-bottom: 20px;
    }
    .item {
      width: 100px;
      height: 100px;
      background-color: lightblue;
      margin: 5px;
    }
    .justify {
      justify-content: space-between; /* Adjusts items in the main axis */
    }
    .align {
      align-content: center; /* Aligns lines in the cross axis */
    }
  </style>
</head>
<body>
  <div class="container justify">
    <div class="item">1</div>
    <div class="item">2</div>
    <div class="item">3</div>
  </div>
  <div class="container align">
    <div class="item">1</div>
    <div class="item">2</div>
    <div class="item">3</div>
    <div class="item">4</div>
    <div class="item">5</div>
  </div>
</body>
</html>

Conclusion:
justify-content is used to distribute space between items along the main axis.
align-content is used to distribute space between lines of items along the cross axis when items wrap onto multiple lines.
Understanding these properties allows for better control over layout and alignment in flex and grid designs, contributing to a more polished and responsive web design.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS position property
/*-------------------------------------*/
The position property in CSS is used to control the positioning of an element within its containing block. 
It determines how an element is placed in the document flow and how it interacts with other elements.

Position Property Values

1. static:
This is the default positioning for all elements. 
Elements are positioned according to the normal document flow, meaning they will appear in the order they are defined in the HTML.
Characteristics: top, right, bottom, and left properties have no effect.
.static {
    position: static;
}
2. relative:
The element is positioned relative to its normal position in the document flow. 
You can adjust it using the top, right, bottom, and left properties, which will move it from its original spot without affecting the layout of surrounding elements.
.relative {
    position: relative;
    top: 10px;  /* Moves the element down 10 pixels */
    left: 20px; /* Moves the element to the right by 20 pixels */
}
3. absolute:
The element is positioned relative to the nearest positioned ancestor (i.e., an ancestor that is not static). 
If no such ancestor exists, it is positioned relative to the initial containing block (usually the viewport).
The element is removed from the normal document flow, so it doesn’t take up space in the layout.
.absolute {
    position: absolute;
    top: 50px;   /* 50 pixels from the top of the nearest positioned ancestor */
    right: 10px; /* 10 pixels from the right edge */
}
4. fixed:
The element is positioned relative to the viewport, meaning it stays in the same place even when the page is scrolled. 
Like absolute, it is also removed from the document flow.
.fixed {
    position: fixed;
    bottom: 0; /* Sticks to the bottom of the viewport */
    right: 0;  /* Sticks to the right edge */
}
5. sticky:
This is a hybrid of relative and fixed. 
An element with position: sticky is treated as relative until it reaches a specified scroll position, at which point it becomes fixed. 
This is often used for headers or elements that should remain visible while scrolling.
The top, right, bottom, or left properties must be defined to specify the point at which it becomes sticky.
.sticky {
    position: sticky;
    top: 0; /* Becomes fixed at the top when scrolled to */
}

Examples of Positioning
1. Static Positioning (default)
div {
    position: static; /* This is the default value */
}
2. Relative Positioning
.relative {
    position: relative;
    top: 20px; /* Moves the element down 20 pixels */
    left: 10px; /* Moves the element to the right 10 pixels */
}
3. Absolute Positioning
.container {
    position: relative; /* Create a positioning context for absolute children */
}
.absolute {
    position: absolute;
    top: 50px; /* Positioned 50 pixels from the top of the nearest positioned ancestor */
}
One way to center an element vertically and horizontally using CSS positioning:
.absolute center {
  position: absolute;
  top: 0;
  right:0;
  left:0;
  bottom:0;
  margin:auto;
}
4. Fixed Positioning
.fixed {
    position: fixed;
    bottom: 0; /* Always at the bottom of the viewport */
    left: 0; /* Always at the left of the viewport */
}
5. Sticky Positioning
.sticky {
    position: sticky;
    top: 0; /* Becomes fixed when scrolled to the top */
}

Summary of Key Points
The position property is crucial for layout control in CSS.
Elements can be positioned in the normal flow (static), offset from their normal position (relative), or positioned in relation to their nearest ancestor (absolute).
fixed keeps elements in place relative to the viewport, while sticky allows elements to scroll until they reach a certain point.

Understanding how to effectively use the position property is essential for creating complex and responsive layouts in web design.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS @media rule
/*-------------------------------------*/
The @media rule in CSS is used to apply styles based on specific conditions, known as media queries. 
These queries are used to make your web design responsive by adapting styles depending on things like the viewport width, device characteristics, and more.

Basic Syntax:
@media (feature: value) {
  selector {
    /* styles go here */
  }
}
In this syntax:
1. feature is a media feature (such as screen width, height, orientation, etc.).
2. value is the condition you want to check for (like a specific width or orientation).
3. Inside the curly braces {}, you place the CSS selector and the styles you want to apply when the media condition is met.

Common Media Features

1. width or min-width / max-width:
Target based on the width of the viewport.
@media (max-width: 768px) {
  body {
    background-color: lightblue;
  }
}
In this example, when the viewport width is 768px or smaller, the body background color will be set to light blue.
2. height or min-height / max-height:
Target based on the height of the viewport.
@media (min-height: 500px) {
  div {
    font-size: 1.2rem;
  }
}
The font size will increase when the viewport height is at least 500px.
3. orientation:
You can apply styles based on whether the device is in landscape or portrait orientation.
@media (orientation: landscape) {
  body {
    font-size: 18px;
  }
}
Here, the font size will change when the device is in landscape orientation.
4. resolution:
Targets specific display resolutions (e.g., retina displays).
@media (min-resolution: 300dpi) {
  img {
    width: 100px;
  }
}
Images will be sized to 100px width on devices with a resolution of 300dpi or higher.
5. aspect-ratio:
Target based on the ratio of the width to height of the viewport.
@media (min-aspect-ratio: 3/2) {
  div {
    padding: 20px;
  }
}
The padding will be applied when the aspect ratio of the viewport is 3:2 or larger.

Media Query Combinations
You can combine multiple media features using logical operators:

1. and: Both conditions must be true.
@media (min-width: 600px) and (orientation: landscape) {
  body {
    font-size: 16px;
  }
}
This rule applies the styles only if the viewport is at least 600px wide and in landscape orientation.

2. or: Either condition can be true.
@media (max-width: 500px), (orientation: portrait) {
  body {
    background-color: lightgray;
  }
}
The background color will be light gray if the viewport is 500px wide or smaller or if the device is in portrait orientation.

3. not: Negates the condition.
@media not (min-width: 600px) {
  p {
    color: red;
  }
}
The paragraph text will be red if the viewport is less than 600px wide.

Example: Responsive Design Using Media Queries
/* Default styles for all viewports */
body {
  font-size: 16px;
}
/* Styles for screens wider than 600px */
@media (min-width: 600px) {
  body {
    font-size: 18px;
  }
}
/* Styles for screens wider than 900px */
@media (min-width: 900px) {
  body {
    font-size: 20px;
  }
}
In this example:
For viewports less than 600px wide, the font size will be 16px.
For viewports between 600px and 899px, the font size will be 18px.
For viewports 900px and wider, the font size will be 20px.

Conclusion
The @media rule allows you to apply specific styles depending on certain conditions, such as viewport width, height, orientation, and other characteristics. 
It's essential for creating responsive designs, ensuring that your website looks great across different devices and screen sizes.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/

The @media rule in CSS is used for applying styles based on certain conditions, such as the width, height, or type of device. The phrase @media only screen is a common pattern used in media queries to target styles specifically for screens (like monitors, tablets, and phones) and exclude other media types like print.

Structure of @media only screen:
@media only screen and (condition) {
  /* CSS rules go here */
}
only screen: This part ensures that the styles inside the media query are applied only to screen devices, such as desktops, laptops, tablets, and smartphones, and not to printed documents.
Conditions: The and keyword is used to combine screen with additional conditions like min-width, max-width, orientation, etc.
Example of Use:

1. Basic Example:
@media only screen and (max-width: 600px) {
  body {
    background-color: lightblue;
  }
}
In this example, if the device's screen width is 600px or smaller, the background color of the body will be set to light blue.

2. Targeting Mobile Devices:
@media only screen and (max-width: 480px) {
  body {
    font-size: 14px;
  }
}
This applies styles only when the screen width is 480px or less, typically targeting smartphones.

3. Targeting Tablets:
@media only screen and (min-width: 600px) and (max-width: 768px) {
  .container {
    padding: 20px;
  }
}
This targets tablets or small devices within the range of 600px to 768px.

Why Use only?
The only keyword is optional but was introduced to prevent older browsers (such as Internet Explorer 8 and below) from applying the styles inside the media query. Although older browsers have mostly fallen out of use, it's still sometimes included for backward compatibility.

Common Use Cases:
Responsive Design: Use @media only screen to create responsive layouts that adapt to different screen sizes (e.g., desktops, tablets, and mobile phones).

Orientation: You can apply styles based on whether the device is in portrait or landscape mode.
@media only screen and (orientation: landscape) {
  /* Styles for landscape mode */
}

High-Resolution Displays: Target high-resolution devices like Retina screens.
@media only screen and (min-resolution: 2dppx) {
  /* Styles for high-resolution displays */
}

Full Example:
@media only screen and (max-width: 768px) {
  body {
    font-size: 16px;
  }
}

@media only screen and (max-width: 480px) {
  body {
    font-size: 14px;
  }
}
This example adjusts the font size for screens of different widths, making the layout more user-friendly on various devices.

In summary, @media only screen is a media query primarily used for applying styles based on the characteristics of the screen, making it a fundamental tool for responsive web design.

/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
Visually Hide text
/*-------------------------------------*/
To visually hide text while keeping it accessible to screen readers, a common CSS pattern known as "visually hidden" or "screen reader only" is used. 
This technique ensures that the text is not displayed on the screen but is still available for assistive technologies like screen readers.

CSS Pattern for Visually Hidden Text
.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0); /* For older browsers for new browsers clip: rect(1px, 1px, 1px, 1px);*/
  white-space: nowrap; /* Prevents text from wrapping */
  border: 0;
}
Explanation of the CSS Properties
1. position: absolute;: Removes the element from the normal document flow, so it doesn’t take up space.
2. width: 1px; height: 1px;: Reduces the size of the element to 1 pixel by 1 pixel, effectively making it invisible.
3. padding: 0; margin: -1px;: Removes any padding or margin to prevent the element from affecting layout.
4. overflow: hidden;: Ensures that any content inside the element that extends beyond the 1px box is not displayed.
5. clip: rect(0, 0, 0, 0);: Clips the element so that no part of it is visible. This is an older method used for older browsers.
6. white-space: nowrap;: Prevents the text from breaking into multiple lines, keeping it confined to a single line (even though it’s hidden).
7. border: 0;: Ensures that no border is visible around the hidden element.

Usage Example
<button class="menu-btn">
  <span class="visually-hidden">Open Menu</span>
  ☰
</button>
In this example, the "Open Menu" text will be hidden visually but read aloud by screen readers, while the visible icon (☰) remains.

When to Use this Pattern
1. Icon-only Buttons: When an icon is used to represent an action (e.g., a hamburger menu for navigation), but the action needs to be described for accessibility.
2. Decorative Images: For decorative images or icons that convey meaning visually but need a text description for users with visual impairments.
3. Form Labels: When a form input’s label is hidden for visual design reasons but needs to be accessible for screen readers.

This pattern is widely used to improve accessibility, providing an easy way to ensure that hidden content is still available for assistive technology.

While the clip property can still be used for rectangular clipping, it is outdated, and
You should prefer the clip-path property for more versatile and modern solutions to clipping elements with different shapes and better browser support.

span[class~="sr-only"] {
  border: 0;
  clip: rect(1px, 1px, 1px, 1px);
  clip-path: inset(50%);
  height: 1px;
  width: 1px;
  overflow: hidden;
  white-space: nowrap;
  position:absolute;
  padding:0;
  margin:-1px;
}

Explanation:
clip-path: inset(50%) is shorthand for inset(50% 50% 50% 50%), which means:
Clip 50% of the element's height from the top.
Clip 50% of the element's width from the right.
Clip 50% of the element's height from the bottom.
Clip 50% of the element's width from the left.
Result:
This creates a very small, centered rectangle. If the element is square (e.g., 100px by 100px), this would leave a 0x0 pixel visible area, essentially hiding the element. If the element is larger or not square, a small portion of it might still be visible.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS clip property
/*-------------------------------------*/
The clip property in CSS is used to clip an element to a specific rectangular region, hiding the rest of the element. 
It was primarily used for absolutely positioned elements. 
However, the clip property is now deprecated in favor of the clip-path property, which provides more flexibility and allows for more complex shapes beyond just rectangles.

Despite being deprecated, the clip property still works in many browsers for backward compatibility but only supports a rectangular shape.

Syntax:
clip: rect(top, right, bottom, left);

Parameters:
The clip property requires the rect() function to define the rectangular region where the element will be visible. The function takes four values:
1. top: Distance from the top edge of the element.
2. right: Distance from the right edge of the element.
3. bottom: Distance from the bottom edge of the element.
4. left: Distance from the left edge of the element.
Example:
<div class="box">This is clipped content</div>
.box {
  position: absolute;
  width: 200px;
  height: 200px;
  background-color: lightblue;
  clip: rect(20px, 150px, 150px, 20px); /* Clips the element */
}
In this example:
The visible part of the element will be a rectangle starting 20px from the top, 150px from the right, 150px from the bottom, and 20px from the left. The rest of the content will be hidden.

Important Notes:
The clip property only works on elements that have position: absolute or position: fixed.
The unit of measurement can be px, em, or other length units.

Deprecation and Use of clip-path:
Since clip is deprecated, the modern way to achieve clipping is with the clip-path property, which offers much more flexibility, including clipping with complex shapes like circles, ellipses, polygons, etc.

Example of clip-path:
.box {
  position: absolute;
  width: 200px;
  height: 200px;
  background-color: lightblue;
  clip-path: circle(50% at 50% 50%); /* Clips the element in a circular shape */
}
Conclusion:
While the clip property can still be used for rectangular clipping, it is outdated, and you should prefer the clip-path property for more versatile and modern solutions to clipping elements with different shapes and better browser support.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS clip-path property
/*-------------------------------------*/
The clip-path property in CSS allows you to create a clipping region, where part of an element is visible, and the rest is hidden. 
Unlike the older clip property (which only supports rectangular shapes), clip-path supports a variety of shapes such as circles, ellipses, polygons, and even custom SVG paths.

Syntax:
clip-path: shape();

Common Shapes You Can Use with clip-path:
1. circle(): Clips the element into a circular shape.
clip-path: circle(radius at center-x center-y);
radius: The size of the circle (in px, %, etc.).
center-x and center-y: The center point of the circle (relative to the element).
Example:
.circle-clip {
  clip-path: circle(50% at 50% 50%); /* Creates a circle at the center */
}

2. ellipse(): Clips the element into an elliptical shape.
clip-path: ellipse(rx ry at cx cy);
rx: Horizontal radius of the ellipse.
ry: Vertical radius of the ellipse.
cx and cy: The center point of the ellipse.
Example:
.ellipse-clip {
  clip-path: ellipse(50% 40% at 50% 50%); /* Centered ellipse */
}

3. polygon(): Clips the element into a polygon with custom-defined points.
clip-path: polygon(x1 y1, x2 y2, x3 y3, ...);
x and y: Coordinates of the polygon's points, relative to the element's bounding box.
Example:
.polygon-clip {
  clip-path: polygon(50% 0%, 100% 100%, 0% 100%); /* Triangle */
}

4. inset(): Clips the element with an inset rectangle, similar to padding.
clip-path: inset(top right bottom left);
Defines the inset from the edges of the element.
Example:
.inset-clip {
  clip-path: inset(10px 20px 30px 40px); /* Cuts out from all sides */
}

path(): Clips the element with an SVG path, allowing for highly customized clipping shapes.
clip-path: path('M path-data');
This uses an SVG path data to define the clipping region, allowing for any custom shape that can be described by SVG.
Example:
.path-clip {
  clip-path: path('M10 10 L90 10 L50 90 Z'); /* Triangle using an SVG path */
}

Examples of clip-path Usage:
1. Circle Clip:
.circle-clip {
  width: 200px;
  height: 200px;
  background-color: lightblue;
  clip-path: circle(50% at 50% 50%);
}
2. Polygon Clip (Triangle):
.triangle-clip {
  width: 200px;
  height: 200px;
  background-color: coral;
  clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
}
3. Ellipse Clip:
.ellipse-clip {
  width: 200px;
  height: 200px;
  background-color: limegreen;
  clip-path: ellipse(100px 50px at 50% 50%);
}
4. Inset Clip:
.inset-clip {
  width: 200px;
  height: 200px;
  background-color: lightcoral;
  clip-path: inset(20px 30px 20px 30px);
}
5. SVG Path Clip:
.path-clip {
  width: 200px;
  height: 200px;
  background-color: yellowgreen;
  clip-path: path('M20 20 H180 V180 H20 Z'); /* Square shape via SVG path */
}
Browser Support:
clip-path is widely supported in modern browsers, although using an SVG path() for clipping may have slightly less support. 
To ensure broader compatibility, make sure to test across browsers or provide fallback styles.

Conclusion:
The clip-path property offers a flexible and powerful way to control the visibility of parts of an element by clipping it to various shapes. 
It’s particularly useful for creating visually interesting designs and interfaces with custom shapes, such as circular images, complex masks, and polygonal layouts. 
For simple shapes, use circle(), ellipse(), or polygon(), while for advanced cases, use path().
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS collapse keyword
/*----------------------------------------------------------------------------------------*/
In CSS, "collapse" is a keyword often used in two main contexts:
1. Table Rows and Columns (border-collapse)
2. Visibility (visibility: collapse)

1. border-collapse for Tables
The border-collapse property is used to define whether the borders of table cells should be separated (the default behavior) or collapsed into a single border.

Values:
1.1 separate: This is the default value where each cell has its own distinct borders.
1.2 collapse: Borders of adjacent table cells are collapsed into a single border.
Example:
table {
  border-collapse: collapse; /* Merges the borders of adjacent cells */
}
td, th {
  border: 1px solid black;
  padding: 10px;
}
Result: Borders between cells will appear as a single line instead of double borders when using collapse.

Demo:
<table>
  <tr>
    <th>Header 1</th>
    <th>Header 2</th>
  </tr>
  <tr>
    <td>Row 1, Cell 1</td>
    <td>Row 1, Cell 2</td>
  </tr>
</table>
With border-collapse: collapse;, the table will have a cleaner appearance with shared borders between cells.

2. visibility: collapse for Visibility
The visibility: collapse property works similarly to visibility: hidden, except it is primarily designed for table rows and columns. When you apply visibility: collapse to a table row or column, it hides the row or column without affecting the layout of the other elements. In non-table elements, it behaves the same as visibility: hidden.

Example:
tr.hidden-row {
  visibility: collapse;
}
Usage:
<table>
  <tr class="hidden-row">
    <td>Hidden Row, Cell 1</td>
    <td>Hidden Row, Cell 2</td>
  </tr>
  <tr>
    <td>Row 2, Cell 1</td>
    <td>Row 2, Cell 2</td>
  </tr>
</table>
Here, the first row will collapse, meaning it will not occupy any space in the table, as if it was completely removed. For non-table elements, it's better to use visibility: hidden instead.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
The z-index property in CSS controls the vertical stacking order of elements that overlap each other. Elements with a higher z-index value are positioned "above" elements with a lower z-index value when they overlap. The z-index property only works on elements with a position value other than static (e.g., relative, absolute, fixed, or sticky).

Key Points About z-index:
1. Stacking Context:
The z-index property defines the stacking order of elements within a "stacking context."
A stacking context is formed when an element has a position value of relative, absolute, fixed, or sticky and its z-index is explicitly set or certain CSS properties like opacity, transform, or filter are applied.

2. Higher z-index Comes to the Front:
Elements with a higher z-index will appear in front of elements with a lower z-index.

3. Default Value:
The default value of z-index is auto, which means it follows the default stacking order without any explicit prioritization.

4. Works with Positioned Elements:
The z-index property only works on elements that have their position property set to relative, absolute, fixed, or sticky. It does not apply to elements with position: static (the default positioning).

Syntax:
element {
  position: relative; /* Or absolute, fixed, sticky */
  z-index: 10;        /* Higher number means the element is closer to the viewer */
}

Example:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Z-Index Example</title>
  <style>
    .box {
      width: 100px;
      height: 100px;
      position: absolute;
    }

    .box1 {
      background-color: red;
      z-index: 1; /* Lower value, will be behind */
      top: 50px;
      left: 50px;
    }

    .box2 {
      background-color: green;
      z-index: 10; /* Higher value, will be on top */
      top: 80px;
      left: 80px;
    }

    .box3 {
      background-color: blue;
      z-index: 5; /* In between */
      top: 110px;
      left: 110px;
    }
  </style>
</head>
<body>
  <div class="box box1"></div>
  <div class="box box2"></div>
  <div class="box box3"></div>
</body>
</html>
In this example:
The red box (box1) has a z-index of 1 and appears behind the others.
The green box (box2) has the highest z-index of 10 and appears on top.
The blue box (box3) has a z-index of 5 and appears between the other two boxes.

Important Concepts:
1. Stacking Context Creation: A stacking context is created in the following situations:
Elements with a position value of relative, absolute, fixed, or sticky and a non-auto z-index.
Elements with opacity less than 1.
Elements with transform, filter, will-change, or perspective.
Flexbox items with z-index set to something other than auto.

2. z-index Only Works Within Stacking Contexts:
If two elements are in different stacking contexts, their z-index values only affect stacking within their own context, not across contexts.

3. Negative z-index:
You can assign negative values to z-index, which will place elements behind their parent or sibling elements.

Example of Stacking Context:
.parent {
  position: relative;
  z-index: 1; /* Creates a stacking context */
}

.child {
  position: absolute;
  z-index: 2; /* Stacks within the parent's stacking context */
}

Default Stacking Order (without z-index):
1. Backgrounds and borders of the root element.
2. Descendant elements with position: static.
3. Positioned elements (with relative, absolute, fixed, or sticky).

Conclusion:
The z-index property is crucial for managing how elements overlap on a web page. When used properly in combination with positioning (relative, absolute, etc.), it helps control the visual layering of elements.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
CSS float property
The float property in CSS is used to position elements to the left or right within their containing element, allowing text and other inline elements to wrap around them. It was originally designed to allow text to flow around images, but it can be applied to any block-level element.

Syntax:
element {
  float: left | right | none | inherit;
}

Values:
1. left: Floats the element to the left of its container, allowing other content to wrap around its right side.
2. right: Floats the element to the right of its container, allowing other content to wrap around its left side.
3. none: Default value, the element does not float, and behaves normally within the document flow.
4. inherit: Inherits the float value from its parent element.

How float Works:
When an element is floated, it is taken out of the normal document flow and aligned to the left or right of its containing block.
Other block-level elements will ignore the floated element and position themselves normally, while inline content (like text) will wrap around the floated element.

Example:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Float Example</title>
  <style>
    .container {
      border: 1px solid #333;
      padding: 20px;
    }

    .float-left {
      width: 150px;
      height: 150px;
      float: left;
      background-color: #f4a261;
      margin-right: 20px;
    }

    .float-right {
      width: 150px;
      height: 150px;
      float: right;
      background-color: #2a9d8f;
      margin-left: 20px;
    }

    .content {
      background-color: #f0efeb;
      padding: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="float-left"></div>
    <div class="float-right"></div>
    <p class="content">
      This is a paragraph of text that wraps around two floated boxes. The orange box is floated to the left, and the green box is floated to the right. The content will fill the space between them and wrap around as necessary.
    </p>
  </div>
</body>
</html>
Explanation:
The orange box (.float-left) is floated to the left, and the green box (.float-right) is floated to the right. The paragraph text (.content) wraps around both boxes.

Common Issues with float:
1. Collapsed Parent Container: When all child elements inside a container are floated, the parent container may collapse because floated elements are taken out of the normal flow. To prevent this, you can use clearing techniques.
2. Clearing Floats: The clear property is used to stop an element from floating next to floated elements. It can be applied with values left, right, or both.

Example of clearing:
.clearfix::after {
  content: "";
  display: block;
  clear: both;
}
Then apply clearfix to the parent container to ensure that it expands to contain the floated elements.

3. Overflow Auto/Hidden: Another way to clear floats is by setting the overflow property on the parent container:
.container {
  overflow: auto; /* or hidden */
}

Example of a Collapsed Parent and Clearing Floats:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Clear Floats Example</title>
  <style>
    .container {
      border: 1px solid #333;
      padding: 20px;
      /* If we don't clear the float, the container height will collapse */
    }

    .float-left {
      width: 150px;
      height: 150px;
      float: left;
      background-color: #f4a261;
      margin-right: 20px;
    }

    .float-right {
      width: 150px;
      height: 150px;
      float: right;
      background-color: #2a9d8f;
      margin-left: 20px;
    }

    .clearfix::after {
      content: "";
      display: block;
      clear: both;
    }
  </style>
</head>
<body>
  <div class="container clearfix">
    <div class="float-left"></div>
    <div class="float-right"></div>
    <p>
      This text wraps around both floated boxes. Since we added the clearfix, the container properly expands to contain the floated elements.
    </p>
  </div>
</body>
</html>
Use Cases for float:
Wrapping Text Around Images: Classic use case for float where text wraps around images.
Simple Layouts: Floats were commonly used in older layouts before Flexbox and CSS Grid. Nowadays, using float for layout design is less common because Flexbox and Grid are more powerful and flexible.
Creating Columns: Floats can be used to create column layouts by floating multiple elements left or right.

When to Avoid float:
1. Modern Layouts: Flexbox and Grid Layout have largely replaced the need for float when building complex layouts. They are easier to control and handle responsiveness better.
2. Clearing Hassles: Floats can cause issues with clearing and collapsing parent containers, making layout management more complex.

Conclusion:
The float property is useful for certain tasks, such as wrapping text around images or creating simple layouts. However, it is less suited for complex layouts, where modern layout systems like Flexbox or CSS Grid should be preferred.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/

The content property in CSS is used in combination with the ::before and ::after pseudo-elements to insert content onto a web page. This content is not part of the document's HTML but is generated by CSS.

It is often used to add decorative elements, icons, or additional textual content to elements without altering the actual HTML structure.

Syntax:
element::before {
  content: "This is inserted content";
}

element::after {
  content: "This is inserted content";
}

Values:
none: No content is inserted. This is the default.
text: You can insert textual content between quotation marks.
url(): Used to insert content from an external resource like an image or a file.
attr(): This allows you to retrieve the value of an attribute of the element (e.g., attr(title)).
counter(): Used for inserting counter values, often for numbered lists.
open-quote / close-quote: These can insert opening or closing quotation marks based on the locale or quotes property.

Example:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Content Property Example</title>
  <style>
    .button::before {
      content: "🔥 "; /* Adds fire emoji before button text */
    }

    .quote::before {
      content: open-quote; /* Adds opening quotation mark */
    }

    .quote::after {
      content: close-quote; /* Adds closing quotation mark */
    }

    .image-container::after {
      content: url('star.png'); /* Inserts an image after the content */
      display: inline-block;
      width: 20px;
      height: 20px;
    }
  </style>
</head>
<body>
  <button class="button">Click me</button>

  <p class="quote">This is a quoted text.</p>

  <div class="image-container">
    This is some text with an image after it
  </div>
</body>
</html>

Explanation:
The ::before pseudo-element is used to insert the fire emoji before the text of the button.
The ::before and ::after pseudo-elements are used on the paragraph to add opening and closing quotes around the text.
An image (star.png) is inserted after the text in the .image-container.

Common Use Cases:
1. Decorative Icons: Adding icons or symbols before or after elements without altering the HTML.
2. Quotes: Automatically adding quotation marks around block quotes or text elements.
3. Generated Content: Dynamically adding content such as numbering using counter() or inserting the value of an attribute using attr().
4. Clearfixes: Using ::after to add an invisible element to clear floats.

More Advanced Example:
/* Adding a counter before list items */
ol {
  counter-reset: section; /* Initialize counter */
}

li::before {
  counter-increment: section; /* Increment counter for each list item */
  content: counter(section) ". "; /* Display counter before list item */
  font-weight: bold;
}
This will automatically number each list item with a counter value.

attr() Example:
a::before {
  content: attr(href); /* Inserts the value of the href attribute before the link text */
  color: red;
}
In this example, if a link has href="https://example.com", the text "https://example.com" will appear before the link.

Conclusion:
The content property in CSS is a powerful tool that can dynamically insert content into the DOM using pseudo-elements (::before and ::after). This allows for stylistic and decorative adjustments without modifying the HTML itself, enabling cleaner, more maintainable code.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/


CSS variables, also known as custom properties, allow you to store values that can be reused throughout a CSS file. 
They are particularly useful for maintaining consistent styling, reducing repetition, and making it easier to update themes or styles in large projects.

Defining CSS Variables:
CSS variables are defined using the -- syntax and are scoped by default to the selector they are declared in (typically :root for global scope).
:root {
  --main-color: #3498db;
  --font-size: 16px;
}

Using CSS Variables:
You can use the var() function to reference and apply the value of a CSS variable.
body {
  color: var(--main-color);
  font-size: var(--font-size);
}
Example:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CSS Variables</title>
  <style>
    :root {
      --primary-color: #3498db;
      --secondary-color: #2ecc71;
      --padding: 10px;
    }

    body {
      background-color: var(--primary-color);
      color: white;
      padding: var(--padding);
    }

    button {
      background-color: var(--secondary-color);
      padding: var(--padding);
      border: none;
      color: white;
    }
  </style>
</head>
<body>
  <h1>Hello World</h1>
  <button>Click Me</button>
</body>
</html>

Advantages:
Reusability: Define a value once and reuse it throughout the stylesheet.
Maintainability: Update the variable’s value in one place, and it reflects everywhere.
Theming: Easily create themes by changing variable values.
Dynamic Values: CSS variables can be updated dynamically via JavaScript.
CSS variables are an excellent tool for writing cleaner, more maintainable, and scalable styles.

/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/

The :root selector in CSS is a pseudo-class that targets the highest-level or root element of the document, which in HTML is always the <html> element. 
It is commonly used to define global CSS variables (custom properties) because the variables defined within :root are accessible throughout the entire document.

Example of :root:
:root {
  --main-color: #3498db;
  --padding: 20px;
  --font-size: 16px;
}

body {
  color: var(--main-color);
  padding: var(--padding);
  font-size: var(--font-size);
}

How it works:
Global Scope: The :root selector ensures that variables (e.g., --main-color, --padding, etc.) are defined globally and can be used anywhere in the stylesheet. 
This is particularly helpful when you want consistency across multiple elements or sections of the page.
Hierarchy: The :root selector has a higher specificity than the html selector, though in most cases, they behave similarly when used for global styles. 
However, :root is preferred for defining CSS variables because it explicitly refers to the document's root.

Usage with JavaScript:
CSS variables defined in :root can also be modified dynamically using JavaScript.
document.documentElement.style.setProperty('--main-color', '#e74c3c');
Example:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Using :root Selector</title>
  <style>
    :root {
      --primary-color: #3498db;
      --secondary-color: #2ecc71;
    }

    body {
      background-color: var(--primary-color);
      color: white;
    }

    button {
      background-color: var(--secondary-color);
      color: white;
      padding: 10px;
      border: none;
    }
  </style>
</head>
<body>
  <h1>Welcome to the Page</h1>
  <button>Click Me</button>
</body>
</html>
Benefits of Using :root:
Global Variables: Allows you to define global variables that can be reused throughout the document.
Theming: Simplifies switching between themes or making site-wide style updates.
Centralized Control: Makes your CSS easier to maintain and modify by centralizing the core styling values.
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------*/


The list-style-type property in CSS is used to define the type of marker (bullet, number, etc.) that will be used for items in a list. This applies to both unordered lists (<ul>) and ordered lists (<ol>), as well as any list item (<li>).

Syntax:
list-style-type: value;

Values:
Here are some common values you can use with list-style-type:

For Unordered Lists (<ul>):
disc: Default bullet (●)
circle: Hollow circle (○)
square: Square bullet (■)
none: No marker

Example:
ul {
  list-style-type: square;
}

For Ordered Lists (<ol>):
decimal: Numbers (1, 2, 3, ...)
lower-roman: Lowercase Roman numerals (i, ii, iii, ...)
upper-roman: Uppercase Roman numerals (I, II, III, ...)
lower-alpha: Lowercase letters (a, b, c, ...)
upper-alpha: Uppercase letters (A, B, C, ...)
none: No marker
Example:
ol {
  list-style-type: upper-roman;
}

Other Options:
armenian: Traditional Armenian numbering.
georgian: Traditional Georgian numbering.
hebrew: Hebrew alphabetic numbering.
cjk-ideographic: Chinese, Japanese, Korean ideographic numbering.
decimal-leading-zero: Numbers with leading zeros (01, 02, 03, ...).

Example: Customizing Lists
<ul style="list-style-type: circle;">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>

<ol style="list-style-type: lower-alpha;">
  <li>First</li>
  <li>Second</li>
  <li>Third</li>
</ol>

Usage Tips:
You can combine list-style-type with other list-related properties like list-style-position and list-style-image for more complex list styling.
When setting list-style-type: none, this effectively removes the bullets or numbers, often useful for custom styling with images or icons.